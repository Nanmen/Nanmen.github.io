<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[18书单与学习计划]]></title>
      <url>%2Farchives%2F5e98de26.html</url>
      <content type="text"><![CDATA[18书单和学习计划书单 《Java编程思想》&nbsp;&nbsp; 深刻理解java中的基础核心思想。 《effective java》&nbsp;&nbsp; 养成良好代码习惯，改善编码能力 《java8实战》&nbsp;&nbsp; 熟悉和掌握java8中新特性以及lambda表达式等 《java编程的逻辑》&nbsp;&nbsp; java 基础核心（待购买） 后面书单待续 学习计划 只是个初略的学习方向和计划，并没有太多详细的规划，希望自己能好好做到吧，18年提升自己的能力多一点。 java：基础更加要打好，javaNIO,并发包等系列知识的学习。相关框架原理代码的初步浏览。 python：用来自我学习相关爬虫和大数据相关的知识。参考链接： 根据python入门大数据系列 莫烦python]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java面试题]]></title>
      <url>%2Farchives%2F1491d7b8.html</url>
      <content type="text"><![CDATA[java面试题 Q:对于依赖倒置原则（Dependency Inversion Principle，DIP），依赖注入（Dependency Injection，DI）和控制反转（Inversion of Control，IoC）容器，你是怎么理解的？ A 依赖倒置原则（Dependency Inversion Principle, DIP） 这个设计准则某种程度上和依赖注入模式有些关联。DIP的出发点是：在应用开发中，高层模块不应当直接依赖低层模块。DIP并不意味着依赖注入。这个准则并没有讲到高层模块如何知道调用哪个低层模块。不过这一点通过实现工厂模式接口可以间接获知，或者通过类似Spring框架、Pico容器、Guice或者Apache HiveMind之类的loC容器实现依赖注入从而得知高层模块调用的具体哪个低层模块。 DIP意味着： 1.高层模块不应当依赖低层模块，它们都应当依赖抽象。2.抽象不应该依赖具体实现。具体实现应该依赖抽象。 应用这个准则后，高层模块并不直接同低层模块交互，而是通过一个抽象层来跟低层模块进行交互。这使得需求变更后增加的成本更加灵 活可控。这里有些实现DIP的示例代码片段。 首先定义抽象层： 12345678package principle_dip2; public interface AnimalHandler &#123; public abstract void handle( ); &#125;package principle_dip2; public interface AnimalHelper &#123; public abstract void help( ); &#125; 接着是依赖于抽象类而非具体实现的高层代码。 1234567891011121314151617181920212223242526272829package principle_dip2;public class CircusService &#123; AnimalHandler handler; public void setHandler(AnimalHandler handler) &#123; this.handler = handler; &#125; public void showStarts( ) &#123; //code omitted for brevity handler.handle( ); &#125;&#125;package principle_dip2;public class TigerHandler implements AnimalHandler&#123; AnimalHelper helper; public void setHelper(AnimalHelper helper) &#123; this.helper = helper; &#125; public void handle( )&#123; //... helper.help( ); //... &#125;&#125;package principle_dip2;public class TigerHelper implements AnimalHelper&#123; public void help( )&#123; //...... &#125;&#125; 依赖注入模式（Dependency Injection） ：在运行时将类的依赖注入到代码中。通过将依赖定义为接口，并将实现这个接口的实体类注入到主类的构造器中来实现这个模式。这允许程序员在不同的实现之间转换而不用去修改主类。依赖注入模式可以通过单一责任原则（Single Responsibility Principle）SRP来使得代码高内聚（high cohesion），因为所依赖的通常都是完成独立的功能的对象，例如，（通过DAO进行）数据存取或（通过Service和Delegate类实现）业务服务。 控制反转容器（Inversion of Control Container，IoC） 是一个支持依赖注入的容器。这种方式下，可以采用一个中心容器，例如Spring框架，Guice或者HiveMind，来定义哪个依赖应该使用哪个实体类。Ioc的松耦合性可以带来更多的灵活性，并且在程序运行时更容易去切换到正确的依赖对象上。控制反转模式的基本概念是，不去实际生成对象，而是去定义如何生成对象。不用直接在代码中将模块和服务硬编码在一起，而是在配置文件中描述哪个模块需要哪个服务。容器（例如Spring框架这个IoC容器）会负责将这两者绑定起来。应用IoC的时候，某对象所需的依赖会在创建的时候通过外部实体传入，这些外部实体用来协调系统中的不同对象。也就是说，依赖是被注入到对象中去的。因此，IoC就是关于一个对象如何获得其协作对象的引用的一种责任反转机制。 DI和IoC的真正强大之处在于，在运行时而非编译时绑定类间关系。例如，在Seam框架中，你可以对一个接口进行两种实现：真正的实现和模拟(mock)的实现，而在运行时根据某个属性、另一个文件存在与否或者某个优先值去决定真正调用哪一个实现。这尤其当你希望程序在不同场景下表现不同的行为时，这是非常好用的。DI和IoC的另外一个好处是，使得代码更容易进行单元测试。当然也有其他一些好处，例如，不用使用工厂或者单例模式就可以实现松耦合，其实现方法一致因此适合缺乏经验的程序员，等等。当然，享受这些好处是要付出代价的，例如系统复杂性会随之增加，另外在使用时也需要更加小心，不能因为这个技术受欢迎就滥用，而是在能够真正体现其优势的地方才去使用。 注意：上下文依赖注入（Contexts and Dependency Injection）是用来描述标准依赖注入的一个尝试。CDI是Java EE 6 stack的一部分，也就是说任何一个运行在Java EE 6兼容容器之上的应用都可以轻松使用CDI。Weld就是CDI的一个可参考的实现。 Q: 以你的经验来看，为什么要选择使用Spring框架呢？ A Spring采用层次结构，有超过20个模块可供选用。这就意味着你可以根据需要自由取舍。Spring通过简单Java对象（Plain Old Java Object，POJO）编程简化了J2EE。在Spring中J2EE编程并没有什么特别的。POJO编程提供了代码的持续集成能力和易测性。 Spring框架的核心功能是依赖注入（DI）。DI使得代码的单元测试更加方便、系统更好维护、代码也更加灵活。DI代码自身很容易测试，通过构建实现了应用所需的接口的“模拟”对象就可以进行功能的黑盒测试。DI代码也更容易复用，因为其“被依赖的”功能封装在在定义良好的接口中，允许其他对象根据需要将其插入到所需的对象中，这些对象是在其他应用平台中进行配置的。DI代码更加灵活，由于其天生的松耦合性，它允许程序员仅需考虑自己所需的接口和其他模块暴露出来的接口来就可以决定对象之间如何关联。 Spring支持面向切面编程（Aspect Oriented Programming ，AOP），允许通过分离应用业务逻辑和系统服务从而进行内聚性的开发。AOP支持审计（auditing）、搜集性能和内存指标等功能。 Spring还提供了许多实现基本功能的模板类，使得J2EE开发更加容易。例如，JdbcTemplate类和JDBC、JpaTemplate类和JPA，JmsTemplate类和JMS都可以很好地结合起来使用。RestTemplate类非常简洁，使用这个模板的代码的可读性和可维护性也都很好。 尽量把中间层代码从业务逻辑中剥离出来是很重要的。最好的远程调用方式就是利用Spring的远程接口调用，这个功能支持使用任何消息或者远程技术来完成远程调用。Apache Camel是一个强大的基于已知的包括Bean集成的企业级集成模式的开源集成框架。Apache Camel设计之初就是为了尽可能的和Spring框架能够很好的结合使用。 Spring提供了声明性事务处理，工作调度，身份认证，成熟的MVC web框架以及和其他框架的集成，例如Hibernate、iBatis、JasperReports、JSF、Struts、Tapestry、Seam和Quartz job scheduler等等。 Spring bean对象可以通过Terracotta在不同的JVM之间共享。这就允许使用已有的bean并在集群中共享 ，将Spring应用上下文事件变为分布式事件，还可以通过Spring JMX导出集群bean，使得Spring应用高可用、集群化。Spring还可以和其他集群应用方案集成起来，例如Oracle的Coherance。 Spring倾向于使用未检查异常（unchecked exceptions）和减少不当try，catch和finally代码块（或者finally中的try/catch块）。像JpaTemplate 这样的Spring模板类会负责关闭或释放数据库连接，这避免了潜在的资源泄露问题并提高了代码的可读性。 在非Spring或者Guice这种DI框架中，工厂模式和单例模式可以用来提高代码的松耦合度。使用了Spring可以有效避免这些模式的滥用。 Q: IoC中支持的依赖注入有哪些类型？ A 依赖注入有三种类型： 构造子注入（例如，Spring框架）：依赖是通过构造器参数提供的。 设值方法注入（例如，Spring框架）：依赖是通过JavaBeans属性注入的（ex：setter方法） 接口注入（例如，Avalon）：注入通过接口完成。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客更新步骤]]></title>
      <url>%2Farchives%2Faeaaf0d9.html</url>
      <content type="text"><![CDATA[博客更新步骤如题。为了偷个懒，做个笔记 exec ssh-agent bash eval ssh-agent -s ssh-add “C:\Users\LN\.ssh\id_rsa” git add . git commit -m ‘update _post’ git push origin hexo g -d]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JVM垃圾回收算法及回收器详解]]></title>
      <url>%2Farchives%2F62414ee6.html</url>
      <content type="text"><![CDATA[JVM垃圾回收算法及回收器详解GC Roots我们先来了解一下在Java中是如何判断一个对象的生死的，有些语言比如Python是采用引用计数来统计的，但是这种做法可能会遇见循环引用的问题，在Java以及C#等语言中是采用GC Roots来解决这个问题。如果一个对象和GC Roots之间没有链接，那么这个对象也可以被视作是一个可回收的对象。 Java中可以被作为GC Roots中的对象有： 虚拟机栈中的引用的对象。方法区中的类静态属性引用的对象。方法区中的常量引用的对象。本地方法栈（jni）即一般说的Native的引用对象。 垃圾回收算法标记清除标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。标记清除算法带来的一个问题是会存在大量的空间碎片，因为回收后的空间是不连续的，这样给大对象分配内存的时候可能会提前触发full gc。 复制算法将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM研究表明新生代中的对象98%是朝夕生死的，所以并不需要按照1:1的比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一个Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1(可以通过-SurvivorRattio来配置)，也就是每次新生代中可用内存空间为整个新生代容量的90%，只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。 标记整理复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。 增量算法增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。 垃圾回收器Serial收集器Serial收集器是最古老的收集器，它的缺点是当Serial收集器想进行垃圾回收的时候，必须暂停用户的所有进程，即stop the world。到现在为止，它依然是虚拟机运行在client模式下的默认新生代收集器，与其他收集器相比，对于限定在单个CPU的运行环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾回收自然可以获得最高的单线程收集效率。 Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记－整理“算法。这个收集器的主要意义也是被Client模式下的虚拟机使用。在Server模式下，它主要还有两大用途：一个是在JDK1.5及以前的版本中与Parallel Scanvenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。 通过指定-UseSerialGC参数，使用Serial + Serial Old的串行收集器组合进行内存回收。 ParNew收集器ParNew收集器是Serial收集器新生代的多线程实现，注意在进行垃圾回收的时候依然会stop the world，只是相比较Serial收集器而言它会运行多条进程进行垃圾回收。 ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证能超越Serial收集器。当然，随着可以使用的CPU的数量增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。 -UseParNewGC: 打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收，这样新生代使用并行收集器，老年代使用串行收集器。 Parallel Scavenge收集器Parallel是采用复制算法的多线程新生代垃圾回收器，似乎和ParNew收集器有很多的相似的地方。但是Parallel Scanvenge收集器的一个特点是它所关注的目标是吞吐量(Throughput)。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能够提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用多线程和”标记－整理”算法。这个收集器是在jdk1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是如果新生代Parallel Scavenge收集器，那么老年代除了Serial Old(PS MarkSweep)收集器外别无选择。由于单线程的老年代Serial Old收集器在服务端应用性能上的”拖累“，即使使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，又因为老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合”给力“。直到Parallel Old收集器出现后，”吞吐量优先“收集器终于有了比较名副其实的应用祝贺，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。 -UseParallelGC: 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old的收集器组合进行内存回收。-UseParallelOldGC: 打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行垃圾回收 CMS收集器CMS(Concurrent Mark Swep)收集器是一个比较重要的回收器，现在应用非常广泛，我们重点来看一下，CMS一种获取最短回收停顿时间为目标的收集器，这使得它很适合用于和用户交互的业务。从名字(Mark Swep)就可以看出，CMS收集器是基于标记清除算法实现的。它的收集过程分为四个步骤： 1.初始标记(initial mark)2.并发标记(concurrent mark)3.重新标记(remark)4.并发清除(concurrent sweep)注意初始标记和重新标记还是会stop the world，但是在耗费时间更长的并发标记和并发清除两个阶段都可以和用户进程同时工作。 不过由于CMS收集器是基于标记清除算法实现的，会导致有大量的空间碎片产生，在为大对象分配内存的时候，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前开启一次Full GC。为了解决这个问题，CMS收集器默认提供了一个-XX:+UseCMSCompactAtFullCollection收集开关参数（默认就是开启的)，用于在CMS收集器进行FullGC完开启内存碎片的合并整理过程，内存整理的过程是无法并发的，这样内存碎片问题倒是没有了，不过停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction参数用于设置执行多少次不压缩的FULL GC后跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。 不幸的是，它作为老年代的收集器，却无法与jdk1.4中已经存在的新生代收集器Parallel Scavenge配合工作，所以在jdk1.5中使用cms来收集老年代的时候，新生代只能选择ParNew或Serial收集器中的一个。ParNew收集器是使用-XX:+UseConcMarkSweepGC选项启用CMS收集器之后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制指定它。 由于CMS收集器现在比较常用，下面我们再额外了解一下CMS算法的几个常用参数： UseCMSInitatingOccupancyOnly：表示只在到达阈值的时候，才进行 CMS 回收。为了减少第二次暂停的时间，通过-XX:+CMSParallelRemarkEnabled开启并行remark。如果ramark时间还是过长的话，可以开启-XX:+CMSScavengeBeforeRemark选项，强制remark之前开启一次minor gc，减少remark的暂停时间，但是在remark之后也立即开始一次minor gc。CMS默认启动的回收线程数目是(ParallelGCThreads + 3)/4，如果你需要明确设定，可以通过-XX:+ParallelCMSThreads来设定，其中-XX:+ParallelGCThreads代表的年轻代的并发收集线程数目。CMSClassUnloadingEnabled： 允许对类元数据进行回收。CMSInitatingPermOccupancyFraction：当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是-XX:+CMSClassUnloadingEnabled 激活了)。CMSIncrementalMode：使用增量模式，比较适合单 CPU。UseCMSCompactAtFullCollection参数可以使 CMS 在垃圾收集完成后，进行一次内存碎片整理。内存碎片的整理并不是并发进行的。UseFullGCsBeforeCompaction：设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。一些建议对于Native Memory: 使用了NIO或者NIO框架（Mina/Netty） 使用了DirectByteBuffer分配字节缓冲区 使用了MappedByteBuffer做内存映射 由于Native Memory只能通过FullGC回收，所以除非你非常清楚这时真的有必要，否则不要轻易调用System.gc()。 另外为了防止某些框架中的System.gc调用（例如NIO框架、Java RMI），建议在启动参数中加上-XX:+DisableExplicitGC来禁用显式GC。这个参数有个巨大的坑，如果你禁用了System.gc()，那么上面的3种场景下的内存就无法回收，可能造成OOM，如果你使用了CMS GC，那么可以用这个参数替代：-XX:+ExplicitGCInvokesConcurrent。 此外除了CMS的GC，其实其他针对old gen的回收器都会在对old gen回收的同时回收young gen。 G1收集器G1收集器是一款面向服务端应用的垃圾收集器。HotSpot团队赋予它的使命是在未来替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点： 1.并行与并发：G1能更充分的利用CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。2.分代收集：和其他收集器一样，分代的概念在G1中依然存在，不过G1不需要其他的垃圾回收器的配合就可以独自管理整个GC堆。3.空间整合：G1收集器有利于程序长时间运行，分配大对象时不会无法得到连续的空间而提前触发一次GC。4.可预测的非停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。在使用G1收集器时，Java堆的内存布局和其他收集器有很大的差别，它将这个Java堆分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。 虽然G1看起来有很多优点，实际上CMS还是主流。 与GC相关的常用参数除了上面提及的一些参数，下面补充一些和GC相关的常用参数： -Xmx: 设置堆内存的最大值。 -Xms: 设置堆内存的初始值。 -Xmn: 设置新生代的大小。 -Xss: 设置栈的大小。 -PretenureSizeThreshold: 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配。 -MaxTenuringThrehold: 晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就会加1，当超过这个参数值时就进入老年代。 -UseAdaptiveSizePolicy: 在这种模式下，新生代的大小、eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量 (GCTimeRatio) 和停顿时间 (MaxGCPauseMills)，让虚拟机自己完成调优工作。 -SurvivorRattio: 新生代Eden区域与Survivor区域的容量比值，默认为8，代表Eden: Suvivor= 8: 1。 -XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。 -XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。 -XX:GCTimeRatio:设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。 相关文章 JVM（3）：Java GC算法 垃圾收集器 JVM初探——使用堆外内存减少Full GC JVM GC参数以及GC算法的应用 JVM内存管理–GC算法精解（五分钟让你彻底明白标记/清除算法） JVM 调优 —— GC 长时间停顿问题及解决方法 JVM 优化经验总结 高吞吐低延迟Java应用的垃圾回收优化 Linux HotSopt虚拟机GC线程的CPU占用率 如何估算内存消耗 参考资料 原文出处： ZIWENXIE JVM 垃圾回收算法及回收器详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java23种设计模式概括]]></title>
      <url>%2Farchives%2F5c9c5ce0.html</url>
      <content type="text"><![CDATA[java 23种设计模式概括目录概览创建型模式：关注对象的创建过程 单例模式：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点主要：饿汉式（线程安全，调用效率高，但是不能延时加载）懒汉式（线程安全，调用效率不高，但是可以延时加载）其他：双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）静态内部类式（线程安全，调用效率高。但是可以延时加载）枚举单例（线程安全，调用效率高，不能延时加载） 工厂模式：简单工厂模式：用来生产同一等级结构中的任意产品（对已有产品新增功能，需要修改源代码）虽然能通过工厂来创建对象，但是违反了开闭原则。一旦增加功能需要在原有基础上修改代码。工厂方法模式：用来生产同一等级结构中的固定产品（支持增加任意产品，不用修改源代码）将工厂类调整为工厂接口，需要什么类型的工厂就使用该类实现该工厂，创建相应的产品。 抽象工厂模式：用来生产不同产品族的全部产品（对于增加新的产品，无能为力。可增加一系列的产品族）抽象工厂模式用来生产不同产品族的全部产品，对于只增加产品某一部分则不适用。抽象工厂模式是工厂模式的一种升级版本。 建造者​模式：分离了对象子组件的单独构造（由Builder来负责构建，由Director来负责组装），从而可以构造出复杂的对象。假如一个对象的构建很复杂，需要很多步骤。如果使用了建造者模式，会将其构建对象，和组装成一个对象这两步给分开来构建部分为（builder）和组织部分（director），实现了构建和装配的解耦。 原型模式：通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。所谓原型模式就是构建一个对象的原型，通过原型来创建出新的对象。 行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。 模板方法模式：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。也就是说：假如某些操作代码基本相同，只是其中一部分会经常改变，则可以使用模板方法，将不变的部分作为一个模板，将容易变动的部分让子类来实现。 命令模式（不常用）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志。以及支持可撤销的操作。说白了，就是将一系列的请求命令封装起来，不直接调用真正执行者的方法，这样比较好扩展。 迭代器模式：提供一种方法顺序的访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。也就是开发一个用于迭代某个对象中元素的功能。 观察者模式：也叫（发布-订阅模式）定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象。使它们能够自动更新自己。例如：发广播，游戏中大喇叭，群聊。jdk中提供了抽象主题和抽象观察者的接口，我们可以使用这两个接口来方便的定义自己的观察者模式 中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用。从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式核心：1.就是将网状结构处理成星型结构 2.将多对多处理成一对多 备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。也就是说，不破坏源数据的情况下，将源数据进行一次或者多次的备份。 解释器模式（不常用）：给定一个语言，定义它的文法一种表示。并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。当遇到不同的状态遇到不同的行为的时候，可以使用状态模式。例如：酒店房间的状态，是空闲，预定，还是已入住呢？而且这三种状态都对应着不同的行为，空闲的话就可预定，可预定的话就可入住，已入住的话就不能显示空闲。 策略模式：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。例如：商场中的打折商品，针对不同的客户可能有不同的折扣。那这些算法该怎么定义呢？可以使用策略模式，给每个会员或者商品都指定一个特定的算法，根据不同的算法，打不同的折扣。 职责链模式：将能够处理同一类请求的对象连成一条链，使这些对象都有机会处理请求，所提交的请求沿着链传递。从而避免请求的发送者和接受者之间的耦合关系。链上的对象逐个判断是否有能力处理该请求，如果能则就处理，如果不能，则传给链上的下一个对象。直到有一个对象处理它为止。比如：请假申请，审批人连成一条链，每个人都有机会处理这个假条，但是这个请假申请最终肯定会经过审核（不管审批是否通过）。 访问者模式（不常用）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 结构型模式：关注对象和类的组织 适配器模式：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的类可以一起工作。例如：NBA中的球员来自不同国家，而世界标准语言是英语。那他们不会英语，也不能各自学习所有国家的语言。所以，最好的办法就是请不同的翻译,将这些球员国家的语言翻译成英语。而这些翻译就是适配器！！适配器模式分类：1、类适配器模式（不推荐使用）：由于类适配器模式需要多重继承对一个接口对另一个接口进行适配，而C#,Java不支持多重继承。2、对象适配器模式：采用组合的方式 桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立的变化。而不会直接影响到其他部分。桥接模式解决了多层继承的结构，处理多维度变化的场景，将各个维度设计成独立的继承结构。使各个维度可以独立的扩展在抽象层建立联系。 装饰模式：也叫装饰者模式或者装饰器模式，表示动态的给一个对象添加一些新的功能（利用子类继承父类也可以实现），但是比生成子类方式更灵活。例如：我们每个人身上穿的衣服，鞋子，领带，披风都可以理解为是对人的装饰。 组合模式：将对象组合成树形结构以表示：部分–整体 的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。基本上见到的树形结构都使用到了组合模式。 外观模式：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口。这个接口使得这一子系统更加容易使用。遵守迪米特法则（最少知识原则）。说白了，就可以理解为封装。外观模式的核心：为子系统提供统一的入口，封装子系统的复杂性，便于客户端调用 享元模式：运用共享技术有效的支持大量细粒度对象的重用。它能做到共享的关键就是区分了内部状态（可以共享，不会随环境变化而变化）和外部状态（不可以共享，会随环境变化而变化）。如果项目中有很多完全相同或相似的对象，则可以使用享元模式，节省内存。 代理模式：为其他对象提供一种代理以便控制对这个对象的访问。可以详细控制访问某个类（对象）的方法，在调用这个方法前作的前置处理（统一的流程代码放到代理中处理）。调用这个方法后做后置处理。例如：明星的经纪人，租房的中介等等都是代理代理模式分类：1.静态代理（静态定义代理类，我们自己静态定义的代理类。比如我们自己定义一个明星的经纪人类）2.动态代理（通过程序动态生成代理类，该代理类不是我们自己定义的。而是由程序自动生成）比较重要！！ 参考资料 大话设计模式(带目录完整版).pdf HEAD_FIRST设计模式（中文版）.pdf 尚学堂_高淇java300集最全视频教程【GOF23设计模式】 FangZheng - 博客园]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[并发包总结（二）]]></title>
      <url>%2Farchives%2F3699126a.html</url>
      <content type="text"><![CDATA[java.util.concurrent 包 java并发编程包（二）阻塞队列（BlockingQueue） 系列用法BlockingQueue 通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。下图是对这个原理的阐述： 一个往线程里边放，另外一个线程从里边取的一个BlockingQueue。 一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。 BlockingQueue 的方法 BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下： 抛异常 特定值 阻塞 超时 插入 add(o) offer(o) put(o) offer(o,timeout,timeunit) 移除 remove(o) poll(o) take(o) poll(o,timeout,timeunit) 检查 element(o) peek(o) 四组不同的行为方式解释： 1.抛异常：如果试图的操作无法立即执行，抛一个异常。2.特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。3.阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。4.超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。 无法向一个 BlockingQueue 中插入 null。如果你试图插入 null，BlockingQueue 将会抛出一个 NullPointerException。可以访问到 BlockingQueue 中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o) 方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注：基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。 BlockingQueue 的实现BlockingQueue 是个接口，需要使用它的实现类之一来使用BlockingQueue.实现类有（this in java 6）: ArrayBlockingQueue DelayQueue LinkedBlockingQueue PriorityBlockingQueue SynchronousQueue java中使用BlockingQueue 的例子这里是一个 Java 中使用 BlockingQueue 的示例。本示例使用的是 BlockingQueue 接口的 ArrayBlockingQueue 实现。首先，BlockingQueueExample 类分别在两个独立的线程中启动了一个 Producer 和 一个 Consumer。Producer 向一个共享的 BlockingQueue 中注入字符串，而 Consumer 则会从中把它们拿出来。 12345678910111213141516public class BlockingQueueExample &#123; public static void main(String[] args) throws Exception &#123; BlockingQueue queue = new ArrayBlockingQueue(1024); Producer producer = new Producer(queue); Consumer consumer = new Consumer(queue); new Thread(producer).start(); new Thread(consumer).start(); Thread.sleep(4000); &#125;&#125; 以下是Producer 类。注意它在每次put()调用时是如何休眠一秒钟的。这将导致Consumer 在等待队列中对象的时候发生阻塞。 123456789101112131415161718192021public class Producer implements Runnable&#123; protected BlockingQueue queue = null; public Producer(BlockingQueue queue) &#123; this.queue = queue; &#125; public void run() &#123; try &#123; queue.put("1"); Thread.sleep(1000); queue.put("2"); Thread.sleep(1000); queue.put("3"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 以下是 Consumer 类。它只是把对象从队列中抽取出来，然后将它们打印到 System.out。 12345678910111213141516171819public class Consumer implements Runnable&#123; protected BlockingQueue queue = null; public Consumer(BlockingQueue queue) &#123; this.queue = queue; &#125; public void run() &#123; try &#123; System.out.println(queue.take()); System.out.println(queue.take()); System.out.println(queue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 数组阻塞队列 ArrayBlockingQueueArrayBlockingQueue 类实现了BlockingQueue 接口。ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其进行初始化的时候设定这个上限，但之后就无法对这个上限进行修改了（ps:因为基于数组实现，具有数组的特性，一旦初始化，大小就无法修改）。ArrayBlockingQueue 内部以FIFO（先进先出）的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾部元素是最短的那个。以下是在使用 ArrayBlockingQueue 的时候对其初始化的一个示例： 12345BlockingQueue queue = new ArrayBlockingQueue(1024);queue.put("1");Object object = queue.take(); 以下是使用了 Java 泛型的一个 BlockingQueue 示例。注意其中是如何对 String 元素放入和提取的： 12345BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(1024);queue.put("1");String string = queue.take(); 延迟队列 DelayQueueDelayQueue 实现了 BlockingQueue 接口。DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口，该接口定义： 123456public interface Delayed extends Comparable&lt;Delayed&lt; &#123; public long getDelay(TimeUnit timeUnit);&#125; DelayQueue 将会在每个元素的 getDelay() 方法返回的值的时间段之后才释放掉该元素。如果返回的是 0 或者负值，延迟将被认为过期，该元素将会在 DelayQueue 的下一次 take 被调用的时候被释放掉。传递给 getDelay 方法的 getDelay 实例是一个枚举类型，它表明了将要延迟的时间段。TimeUnit 枚举将会取以下值： 1234567DAYSHOURSMINUTESSECONDSMILLISECONDSMICROSECONDSNANOSECONDS 正如你所看到的，Delayed 接口也继承了 java.lang.Comparable 接口，这也就意味着 Delayed 对象之间可以进行对比。这个可能在对 DelayQueue 队列中的元素进行排序时有用，因此它们可以根据过期时间进行有序释放。以下是使用 DelayQueue 的例子： 12345678910111213public class DelayQueueExample &#123; public static void main(String[] args) &#123; DelayQueue queue = new DelayQueue(); Delayed element1 = new DelayedElement(); queue.put(element1); Delayed element2 = queue.take(); &#125;&#125; DelayedElement 是我所创建的一个 DelayedElement 接口的实现类，它不在 java.util.concurrent 包里。你需要自行创建你自己的 Delayed 接口的实现以使用 DelayQueue 类。 链阻塞队列LinkedBlockingQueueLinkedBlockingQueue 类实现了BlockingQueue接口。LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。LinkedBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。以下是 LinkedBlockingQueue 的初始化和使用示例代码： 1234567BlockingQueue&lt;String&gt; unbounded = new LinkedBlockingQueue&lt;String&gt;();BlockingQueue&lt;String&gt; bounded = new LinkedBlockingQueue&lt;String&gt;(1024);bounded.put("Value");String value = bounded.take(); 具有优先级的阻塞队列PriorityBlockingQueuePriorityBlockingQueue 类实现了 BlockingQueue 接口。PriorityBlockingQueue 是一个无界的并发队列。它使用了和类 java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。注意 PriorityBlockingQueue 对于具有相等优先级(compare() == 0)的元素并不强制任何特定行为。同时注意，如果你从一个 PriorityBlockingQueue 获得一个 Iterator 的话，该 Iterator 并不能保证它对元素的遍历是以优先级为序的。以下是使用 PriorityBlockingQueue 的示例： 1234567BlockingQueue queue = new PriorityBlockingQueue();//String implements java.lang.Comparablequeue.put("Value");String value = queue.take(); 同步队列SynchronousQueueSynchronousQueue 类实现了 BlockingQueue 接口。SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。 阻塞双端队列 BlockingDequejava.util.concurrent 包里的 BlockingDeque 接口表示一个线程安放入和提取实例的双端队列。本小节我将给你演示如何使用 BlockingDeque。BlockingDeque 类是一个双端队列，在不能够插入元素时，它将阻塞住试图插入元素的线程；在不能够抽取元素时，它将阻塞住试图抽取的线程。deque(双端队列) 是 “Double Ended Queue” 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。 一个 BlockingDeque - 线程在双端队列的两端都可以插入和提取元素。一个线程生产元素，并把它们插入到队列的任意一端。如果双端队列已满，插入线程将被阻塞，直到一个移除线程从该队列中移出了一个元素。如果双端队列为空，移除线程将被阻塞，直到一个插入线程向该队列插入了一个新元素。 BlockingDeque 的方法BlockingDeque 具有 4 组不同的方法用于插入、移除以及对双端队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下： 抛异常 特定值 阻塞 超时 插入 addFirst(o) offerFirst(o) putFirst(o) offerFirst(o, timeout, timeunit) 移除 removeFirst(o) pollFirst(o) takeFirst(o) pollFirst(timeout, timeunit) 检查 getFirst(o) peekFirst(o) 抛异常 特定值 阻塞 超时 插入 addLast(o) offerLast(o) putLast(o) offerLast(o, timeout, timeunit) 移除 removeLast(o) pollLast(o) takeLast(o) pollLast(timeout, timeunit) 检查 getLast(o) peekLast(o) 四组不同的行为方式解释： 1.抛异常：如果试图的操作无法立即执行，抛一个异常。2.特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。3.阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。4.超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。 参考资料 Java 并发工具包 java.util.concurrent 用户指南]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[concurrent并发包总结]]></title>
      <url>%2Farchives%2F9880a961.html</url>
      <content type="text"><![CDATA[java.util.concurrent 包 java并发编程包（一）1.简介通常所说的concurrent包基本有3个package组成java.util.concurrent：提供大部分关于并发的接口和类，如BlockingQueue,Callable,ConcurrentHashMap,ExecutorService, Semaphore等java.util.concurrent.atomic：提供所有原子操作的类， 如AtomicInteger, AtomicLong等；java.util.concurrent.locks:提供锁相关的类, 如Lock, ReentrantLock, ReadWriteLock, Condition等； concurrent包的优点： 首先，功能非常丰富，诸如线程池(ThreadPoolExecutor)，CountDownLatch等并发编程中需要的类已经有现成的实现，不需要自己去实现一套； 毕竟jdk1.4对多线程编程的主要支持几乎就只有Thread, Runnable,synchronized等 concurrent包里面的一些操作是基于硬件级别的CAS(compare and swap),就是在cpu级别提供了原子操作，简单的说就可以提供无阻塞、无锁定的算法； 而现代cpu大部分都是支持这样的算法的； 闭锁CountDownLatchjava.util.concurrent.CountDownLatch 是一个并发构造，它允许一个或多个线程等待一系列指定操作的完成。 通常的使用场景是，某个主线程接到一个任务，起了n个子线程去完成，但是主线程需要等待这n个子线程都完成任务了以后才开始执行某个操作； 演示代码 123456789101112131415161718192021222324252627282930313233343536@Testpublic void demoCountDown()&#123; int count = 10; final CountDownLatch l = new CountDownLatch(count); for(int i = 0; i &lt; count; ++i) &#123; final int index = i; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.currentThread().sleep(20 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread " + index + " has finished..."); l.countDown(); &#125; &#125;).start(); &#125; try &#123; l.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("now all threads have finished");&#125; 只有当前面10个线程执行完成，最后一句话才会执行打印。（ps：10个线程执行顺序不定） Atomic类Atomic相关的类，比如AtomicLong, AtomicInteger等这些；简单的说，这些类都是线程安全的，支持无阻塞无锁定的 123456set()get()getAndSet()getAndIncrement()getAndDecrement()getAndAdd() 等操作 演示代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.hetaoblog.concurrent.test;import java.util.concurrent.CountDownLatch;import java.util.concurrent.atomic.AtomicLong;import org.junit.Test;/** * by http://www.hetaoblog.com * * @author hetaoblog */public class AtomicTest &#123; @Test public void testAtomic() &#123; final int loopcount = 10000; int threadcount = 10; final NonSafeSeq seq1 = new NonSafeSeq(); final SafeSeq seq2 = new SafeSeq(); final CountDownLatch l = new CountDownLatch(threadcount); for (int i = 0; i &lt; threadcount; ++i) &#123; final int index = i; new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; loopcount; ++j) &#123; seq1.inc(); seq2.inc(); &#125; System.out.println("finished : " + index); l.countDown(); &#125; &#125;).start(); &#125; try &#123; l.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("both have finished...."); System.out.println("NonSafeSeq:" + seq1.get()); System.out.println("SafeSeq with atomic: " + seq2.get()); &#125;&#125;class NonSafeSeq &#123; private long count = 0; public void inc() &#123; count++; &#125; public long get() &#123; return count; &#125;&#125;class SafeSeq &#123; private AtomicLong count = new AtomicLong(0); public void inc() &#123; count.incrementAndGet(); &#125; public long get() &#123; return count.longValue(); &#125;&#125; 其中NonSafeSeq是作为对比的类，直接放一个private long count不是线程安全的，而SafeSeq里面放了一个AtomicLong,是线程安全的；可以直接调用incrementAndGet来增加 运行代码，可以得到类似这样的结果finished : 1finished : 0finished : 3finished : 2finished : 5finished : 4finished : 6finished : 8finished : 9finished : 7both have finished….NonSafeSeq:91723SafeSeq with atomic: 100000 可以看到，10个线程，每个线程运行了10,000次，理论上应该有100,000次增加，使用了普通的long是非线程安全的，而使用了AtomicLong是线程安全的； 注意，这个例子也说明，虽然long本身的单个设置是原子的，要么成功要么不成功，但是诸如count++这样的操作就不是线程安全的；因为这包括了读取和写入两步操作； 可以代替synchronized关键字的ReentrantLock在jdk 1.4时代，线程间的同步主要依赖于synchronized关键字，本质上该关键字是一个对象锁，可以加在不同的instance上或者class上，从使用的角度则分别可以加在非静态方法，静态方法，以及直接synchronized(MyObject)这样的用法；concurrent包提供了一个可以替代synchronized关键字的ReentrantLock，简单的说你可以new一个ReentrantLock， 然后通过lock.lock和lock.unlock来获取锁和释放锁；注意必须将unlock放在finally块里面，reentrantlock的好处 是更好的性能， 提供同一个lock对象上不同condition的信号通知 还提供lockInterruptibly这样支持响应中断的加锁过程，意思是说你试图去加锁，但是当前锁被其他线程hold住，然后你这个线程可以被中断； 演示代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.hetaoblog.concurrent.test;import java.util.concurrent.CountDownLatch;import java.util.concurrent.locks.ReentrantLock;import org.junit.Test;public class ReentrantLockDemo &#123; @Test public void demoLock() &#123; final int loopcount = 10000; int threadcount = 10; final SafeSeqWithLock seq = new SafeSeqWithLock(); final CountDownLatch l = new CountDownLatch(threadcount); for (int i = 0; i &lt; threadcount; ++i) &#123; final int index = i; new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; loopcount; ++j) &#123; seq.inc(); &#125; System.out.println("finished : " + index); l.countDown(); &#125; &#125;).start(); &#125; try &#123; l.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("both have finished...."); System.out.println("SafeSeqWithLock:" + seq.get()); &#125;&#125;class SafeSeqWithLock &#123; private long count = 0; private ReentrantLock lock = new ReentrantLock(); public void inc() &#123; lock.lock(); try &#123; count++; &#125; finally &#123; lock.unlock(); &#125; &#125; public long get() &#123; return count; &#125;&#125; 同样以前面的类似Sequence的类举例，通过对inc操作加锁，保证了线程安全；当然，这里get()我没有加锁，对于这样直接读取返回原子类型的函数，我认为不加锁是没问题的，相当于返回最近成功操作的值； 运行结果类似这样，finished : 7finished : 2finished : 6finished : 1finished : 5finished : 3finished : 0finished : 9finished : 8finished : 4both have finished….SafeSeqWithLock:100000 读写锁ReadWriteLockconcurrent包里面还提供了一个非常有用的锁，读写锁ReadWriteLock下面是ReadWriteLock接口的说明：A ReadWriteLock maintains a pair of associated locks, one for read-only operations and one for writing. The read lock may be held simultaneously by multiple reader threads, so long as there are no writers. The write lock is exclusive. 意思是说读锁可以有很多个锁同时上锁，只要当前没有写锁；写锁是排他的，上了写锁，其他线程既不能上读锁，也不能上写锁；同样，需要上写锁的前提是既没有读锁，也没有写锁；两个写锁不能同时获得无需说明，下面一段程序说明下上了读锁以后，其他线程需要上写锁也无法获得 演示代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import org.junit.Test;import java.util.Date;import java.util.concurrent.CountDownLatch;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * @author LN * @create 2018-02-10 15:02 **/public class concurrentTest &#123; @Test public void testRWLock_getw_onr()&#123; ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); final Lock rlock = lock.readLock(); final Lock wlock = lock.writeLock(); final CountDownLatch l = new CountDownLatch(2); //start r thread new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(new Date() + "now to get rlock"); rlock.lock(); try &#123; Thread.currentThread().sleep(20*1000); &#125; catch (InterruptedException ev) &#123; ev.printStackTrace(); &#125; System.out.println(new Date() + "now to unlock rlock"); rlock.unlock(); l.countDown(); &#125; &#125;).start(); //start w lock new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(new Date() + "now to get wlock"); wlock.lock(); System.out.println(new Date() + "now to unlock wlock"); wlock.unlock(); l.countDown(); &#125; &#125;).start(); try &#123; l.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(new Date() + "now to finished"); &#125;&#125; 在试图获取写锁时，写锁线程必须等读锁线程将读锁释放了之后才可以获得写锁。 结果：Sat Feb 10 15:26:09 CST 2018now to get rlockSat Feb 10 15:26:09 CST 2018now to get wlockSat Feb 10 15:26:29 CST 2018now to unlock rlockSat Feb 10 15:26:29 CST 2018now to unlock wlockSat Feb 10 15:26:29 CST 2018now to finished ReadWriteLock的实现是ReentrantReadWriteLock，有趣的是，在一个线程中，读锁不能直接升级为写锁，但是写锁可以降级为读锁；这意思是，如果你已经有了读锁，再去试图获得写锁，将会无法获得， 一直堵住了；但是如果你有了写锁，再去试图获得读锁，没问题； 下面是一段降级的代码， 1234567891011121314151617181920212223@Testpublic void testRWLock_downgrade()&#123; ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); Lock rlock = lock.readLock(); Lock wlock = lock.writeLock(); System.out.println("now to get wloc k"); wlock.lock(); System.out.println("now to get rlock"); rlock.lock(); System.out.println("now to unlock wlock"); wlock.unlock(); System.out.println("now to unlock rlock"); rlock.unlock(); System.out.println("finished");&#125; 参考资料 说一说java的concurrent包-系列文章 Java 并发工具包 java.util.concurrent 用户指南]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker 初识]]></title>
      <url>%2Farchives%2Ffd0b65d2.html</url>
      <content type="text"><![CDATA[Docker 初识目录相关文档 简介 概念 Docekr 基础环境搭建 Docker 运用场景 相关文档 大白话Docker入门（一） 利用Docker构建开发环境详解 宋宝华：Docker 最初的2小时(Docker从入门到入门) 初探Docker Docker实战–部署简单nodejs应用 Docker 镜像加速器 简介Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 概念KVM, Virtualbox, Vmware是虚拟出机器，让每个实例看到一个单独的机器；而Docker是虚拟出操作系统，实现应用之间的隔离，让各个应用觉得自己有一个自己的操作系统，而且彼此之间隔离。 Docker由下面几样东西组成： Docker Client : Docker提供给用户的客户端。Docker Client提供给用户一个终端，用户输入Docker提供的命令来管理本地或者远程的服务器。 Docker Daemon : Docker服务的守护进程。每台服务器（物理机或虚机）上只要安装了Docker的环境，基本上就跑了一个后台程序Docker Daemon，Docker Daemon会接收Docker Client发过来的指令,并对服务器的进行具体操作。 Docker Images : 俗称Docker的镜像，这个可难懂了。你暂时可以认为这个就像我们要给电脑装系统用的系统CD盘，里面有操作系统的程序，并且还有一些CD盘在系统的基础上安装了必要的软件，做成的一张 “只读” 的CD。 Docker Registry : 这个可认为是Docker Images的仓库，就像git的仓库一样，用来管理Docker镜像的，提供了Docker镜像的上传、下载和浏览等功能，并且提供安全的账号管理可以管理只有自己可见的私人image。就像git的仓库一样，docker也提供了官方的Registry，叫做Dock Hub Docker Container : 俗称Docker的容器，这个是最关键的东西了。Docker Container是真正跑项目程序、消耗机器资源、提供服务的地方，Docker Container通过Docker Images启动，在Docker Images的基础上运行你需要的代码。 你可以认为Docker Container提供了系统硬件环境，然后使用了Docker Images这些制作好的系统盘，再加上你的项目代码，跑起来就可以提供服务了。 Docker Container 的示例图： Container和Image 在Docker的世界里，Image是指一个只读的层（Layer），这里的层是AUFS里的概念，最直观的方式就是看一下docker官方给出的图： Docker使用了一种叫AUFS的文件系统，这种文件系统可以让你一层一层地叠加修改你的文件，最底下的文件系统是只读的，如果需要修改文件，AUFS会增加一个可写的层（Layer），这样有很多好处，例如不同的Container可以共享底层的只读文件系统（同一个Kernel），使得你可以跑N多个Container而不至于你的硬盘被挤爆了！这个只读的层就是Image！而如你所看到的，一个可写的层就是Container。 Docker 基础环境搭建（阿里云仓库创建、提交） 首先安装基于你的系统的Docker环境，建议参考docker的官网以及相关问题百度。（注：如果是win10专业版，因为自带了虚拟机Hyper-V,所以可以下载专门匹配的docker for windows 10，其他的window版本，建议下载Docker Toolbox，它包含了运行Docker时需要的一切：Docker客户端、Compose（仅Mac需要）、Kitematic、Machine以及VirtualBox。） 安装完成后一般双击你桌面的快捷图标（Docker Quickstart Terminal），它会初始化去github下载一个虚拟机的默认的default镜像文件，一般这个下载非常慢，建议直接访问https://github.com/boot2docker/boot2docker/releases 下载对应版本的boot2docker.iso然后复制粘贴到C:\Users\LN.docker\machine\cache目录下，这样可以完成docker的首次启动。查看 docker version 我们也可以查看相关的一些命令，查看镜像 docker images、查看容器 docker ps -a 、查看正在运行的容器 docker ps 等。 因为docker默认的官方仓库是https://hub.docker.com , 访问困难，所以我们在拉取镜像的时候一般选择国内的docker仓库，如网易，阿里都有对应的docker镜像仓库。我们拿阿里的仓库镜像做介绍。使用docker info 查看我们是否配备好了国内加速器。 拉取镜像 docker pull centos ，使用阿里云加速。使用命令 sudo docker run -it ubuntu:14.04 /bin/bash ， 运行之后我们就有了一个Ubuntu的基础环境，我们可以把拉取下来的镜像 添加gcc和vim ，添加构建文件Dockerfile 123mkdir myubuntuWithVimAndGcccd myubuntuWithVimAndGcc &amp;&amp; touch Dockerfilevi Dockerfile 1234# Ubuntu 14.04 with vim and gccFROM ubuntu:14.04MAINTAINER Barry Song&lt;ningfan210@163.comRUN apt-get update &amp;&amp; apt-get install -y vim gcc 然后通过命令 sudo docker build -t ubuntu/ubuntuwithvimandgcc . ，试着运行一下,测试下gcc 和 vim ,发现已经装好了， 最后我们可以发布我们的镜像到阿里的自己的仓库中，可以让别人拉取。 Docker 运用场景 （Docker 搭建基础项目环境） 作为示范，我们演示下，在docker环境中搭建一个运行在nodejs环境下的hexo博客。首先编写构建文件Dockerfile： 1234567891011121314151617FROM nodeMAINTAINER NANMENRUN npm install -g hexo --registry=https://registry.npm.taobao.orgRUN mkdir -p hexofileWORKDIR /hexofileRUN hexo initRUN hexo generateEXPOSE 4000CMD ["hexo","server"]~ 然后使用命令 sudo docker build -t hexo/node . 命令构建我们的hexo的镜像，因为hexo运行时是跑在端口4000上，所以我们在执行运行命令的时候需要运用到 -p 命令做端口映射，如sudo docker run -d -p 4000:4000 hexo/node:latest ,然后在浏览器中访问 http://localhost:4000/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IM即时通讯资料整理]]></title>
      <url>%2Farchives%2Fa5d8a8b7.html</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[即时通讯开源软件归纳]]></title>
      <url>%2Farchives%2Fb971456b.html</url>
      <content type="text"><![CDATA[即时通讯开源软件归纳开源归纳因为需要兼容android和ios，所以一翻查找，暂时发现以下待定开源项目： 基于XMPP 进行的二次开发项目，目前有基于服务端的开源项目：Openfire 。 基于MQTT 进行的二次开发项目。 基于MobileIMSDK 的二次开发项目。 基于T-IO 的二次开发项目。 优良归纳XMPP：是基于XML的,有服务器的开源项目ejabberd； ejabberd是基于Jabber/XMPP协议的即时通讯服务器，由GPLv2授权（免费和开放源码），采用Erlang/OTP开发。它的特点是，跨平台，容错，集群和模块化。Ejabberd目前是可扩展性最好的一种Jabber/XMPP服务器，支持分布多个服务器，并且具有容错处理，单台服务器失效不影响整个cluster运作。 完整的XMPP IM 实现（Openfire + Spark + Smack）： 包括服务器端——Openfire，客户端——Spark，XMPP 传输协议的实现——Smack（记住，XMPP是一个协议，协议是需要实现的，Smack起到的就是这样的一个作用）。三者都是基于Java 语言的实现。 缺点：其中XMPP是基于XML的,并且不支持消息质量QOS, 所以本身并没有消息重传的机制,从而会导致丢消息。 MQTT：是基于二进制的,支持QOS,并且已成为物联网的协议标准。 MobileIMSDK：是一个比较成熟的兼容android、IOS、java标准平台的一个开源项目。有比较成熟的基于其上的开发的demo和示例。 T-IO：有一个完善比较全面的开源项目，但是文档和示例比较少，估计需要自己爬不少的坑（慎选）。 参考文档 XMPP协议的原理介绍 基于openfire+smack的Android、Web、PC开发 iOS和Android使用MQTT协议实现消息推送和即时通讯（替代XMPP，已经有TMS MQTT） Android mqtt即时通讯方案 一个专为移动端开发的原创即时通讯框架，超轻量级、高度提炼，完全基于UDP协议，支持iOS、Android、标准Java平台。 基于Websocket的IM即时通讯技术/IM 即时通讯技术在多应用场景下的技术实现，以及性能调优（iOS视角）.md Lhttp个基于websocket服务端框架 t-io: 不仅仅是百万级即时通讯框架]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记推送失败——git命令之ssh-add学习]]></title>
      <url>%2Farchives%2Fe8996bd7.html</url>
      <content type="text"><![CDATA[推送失败——git命令学习起因昨天更新文档推送设计模式的笔记，在git bash 命令框下输入以前的 1hexo g -d 却给我报了个错误,Could not open a connection to your authentication agent，一翻百度发现解决方法如下： 1.exec ssh-agent bash2.eval ssh-agent -s3.ssh-add “C:\Users\LN.ssh\id_rsa” 将相应的秘钥地址改为你自己的地址，然后就可以愉快的输入测试命令了 12ssh -T git@github.comssh -T git@git.coding.net 测试通过，ok，然后就可以输入部署命令了。 参考文档 win下给 Git Bash 添加私钥时ssh-add报错的解决办法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[大话设计模式——读后感（2）]]></title>
      <url>%2Farchives%2Fd1e9f0a5.html</url>
      <content type="text"><![CDATA[大话设计模式——读后感（2）Tip2备忘录模式 备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 Originator（发起人）：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。 Originator可根据需要决定Memento存储Originator的哪些内部状态 Memento（备忘录）：负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。 备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到 先前状态所需的所有数据。 Caretaker（管理者）：负责保存好备忘录Memento，不能对备忘录的内存进行操作或检查。 备忘录模式代码实现以一个Emp实体对象来作为例子 首先，创建一个发起人：发起人内部保存着需要备忘的属性，它负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。 123456789101112131415161718//发起人：发起人内部有自身的内部状态，并且发起人可以创建备忘录和恢复备忘录public class EmpOriginator &#123; //需要备份的自身属性 private String ename; private int age; private double salary; //备份 public EmpMemento memento()&#123; return new EmpMemento(this);//将当前自身对象备份 &#125; //恢复 public void recovery(EmpMemento emp)&#123; this.ename = emp.getEname(); this.age = emp.getAge(); this.salary = emp.getSalary(); &#125; //省略get，set和带参构造器&#125; 创建备忘录对象：备忘录就是用来备份发起人的数据，所以构造器需要提供一个发起人对象 1234567891011121314//备忘录对象public class EmpMemento &#123; //自身属性 private String ename; private int age; private double salary; //构造备忘录对象时，需要传入一个需要备忘的对象（发起人） public EmpMemento(EmpOriginator emp) &#123; this.ename = emp.getEname(); this.age = emp.getAge(); this.salary = emp.getSalary(); &#125; //省略3个属性的set,get方法&#125; 开始创建一个备忘录的管理者 1234567891011//管理者：管理备忘录对象public class CareTaker &#123; //需要管理的备忘录对象，这里也可以使用一个list容器来存储。这样可以备份多个点 private EmpMemento empMemento; public EmpMemento getEmpMemento() &#123; return empMemento; &#125; public void setEmpMemento(EmpMemento empMemento) &#123; this.empMemento = empMemento; &#125;&#125; 单次备份测试：测试只能备份一次的备忘录 12345678910111213141516171819public static void main(String[] args) &#123; CareTaker taker = new CareTaker();//构建一个备忘录管理者 //构建发起人 EmpOriginator emp = new EmpOriginator("张三", 20, 4000); System.out.println("第一次："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary()); //备份 taker.setEmpMemento(emp.memento()); //备份完了后再修改 emp.setEname("李四"); emp.setAge(30); emp.setSalary(50000); //然后再次打印 System.out.println("修改后："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary()); //开始恢复 emp.recovery(taker.getEmpMemento()); System.out.println("恢复后："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary());&#125; 测试结果如下： 第一次：张三---20---4000.0 修改后：李四---30---50000.0 恢复后：张三---20---4000.0 但是，这样的效果是只能备份一次。有时候我们需要备份多个点，根据需要来还原具体哪次的数据 多次备份使用Stack来存储备份数据，进行多次备份。用Stack的好处是Stack是后进先出的，也就是说：你最近一次备份的数据会优先获取到。 修改管理者中的代码： 12345678910111213141516171819202122232425262728import java.util.Stack;//管理者：管理备忘录对象public class CareTaker &#123; //需要管理的备忘录对象，这里也可以使用一个list容器来存储。这样可以备份多个点 //或者使用一个Stack栈来保存，因为Stack是后进先出的 private Stack&lt;EmpMemento&gt; stack = new Stack&lt;EmpMemento&gt;(); //备份emp数据到栈中 public void mementoEmp(EmpMemento emp)&#123; stack.push(emp); &#125; //从栈中获取最近一次备份的emp数据 public EmpMemento getEmpForStack()&#123; if (!stack.empty()) &#123; return stack.peek();//peek只获取，不删除 &#125;else&#123; return null; &#125; &#125; //从栈中获取最近一次备份的emp数据,并且从栈中删除该数据 public EmpMemento getEmpForStackAndRemove()&#123; if (!stack.empty()) &#123; return stack.pop();//pop获取后删除该元素 &#125;else&#123; return null; &#125; &#125;&#125; 再次测试：后进先出，也就是说。恢复的话恢复的是最后一次备份的数据 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) &#123; CareTaker taker = new CareTaker();//构建一个备忘录管理者 //构建发起人 EmpOriginator emp = new EmpOriginator("张三", 20, 4000); System.out.println("第一次："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary()); //第1次备份 taker.mementoEmp(emp.memento()); //备份完了后再修改 emp.setEname("李四"); emp.setAge(30); emp.setSalary(50000); //然后再次打印 System.out.println("1修改后："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary()); //第2次备份 taker.mementoEmp(emp.memento()); //备份完了后再修改 emp.setEname("李四2"); emp.setAge(32); emp.setSalary(52000); //然后再次打印 System.out.println("2修改后："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary()); //第3次备份 taker.mementoEmp(emp.memento()); //备份完了后再修改 emp.setEname("李四3"); emp.setAge(33); emp.setSalary(32000); //然后再次打印 System.out.println("3修改后："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary()); //第4次备份 taker.mementoEmp(emp.memento()); //开始恢复 emp.recovery(taker.getEmpForStack());//恢复的是第4次备份的数据（3修改后） System.out.println("恢复后："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary());&#125; 测试结果如下： 第一次：张三---20---4000.0 1修改后：李四---30---50000.0 2修改后：李四2---32---52000.0 3修改后：李四3---33---32000.0 恢复后：李四3---33---32000.0 当然，也可以恢复之后把它从栈中删除。 测试：恢复之前从栈中删除两个最近的数据 12345//开始恢复taker.getEmpForStackAndRemove();//删除最近一次的备份taker.getEmpForStackAndRemove();//删除最近一次的备份emp.recovery(taker.getEmpForStack());//此时获取的是原来未删除时倒数第二次的备份System.out.println("恢复后："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary()); 此时的结果就是如下：可见，这里已经把2和3给删除了 第一次：张三---20---4000.0 1修改后：李四---30---50000.0 2修改后：李四2---32---52000.0 3修改后：李四3---33---32000.0 恢复后：李四---30---50000.0 总结-应用场景 棋类游戏中的悔棋操作 软件中的撤销操作 数据库中的事务回滚操作 常用软件中的历史记录功能 参考资料 大话设计模式(带目录完整版).pdf 备忘录模式（Memento） - FangZheng - 博客园]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新的开始]]></title>
      <url>%2Farchives%2Fb585e161.html</url>
      <content type="text"><![CDATA[新的开始初整理 —— 大话设计模式Tip1 读后笔记UML类图整理 动物类 (‘+’ 表示public ，’-‘ 表示private，’#’表示protected) 第一层类的名称 (抽象类是用斜体表示) 第二层类的特性 第三层类的函数方法 飞翔 接口图 顶层是\&lt;&gt;显示 第二层是方法 另一种接口表现法是棒棒糖表示法（表现的唐老鸭实现了‘讲人话’的方法）。 继承：空心三角形+实线 表示。 实现：空心三角形+虚线 表示。 关联：实线箭头 表示。 聚合：空心的菱形+实线箭头 表示。（聚合表示一种弱的‘拥有关系’，体现的是A对象可以包含B对象，但B对象不是A对象的一部分[DPE]） 合成：菱形+实线箭头，两端数字为基数，表示一端的类可以有几个实例。（合成是一种强的拥有关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样） 依赖：虚线箭头表示。 简单工厂模式简单工厂模式：用一个单独的类来做这个创造实例的过程。 策略模式策略模式：是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。 策略模式的Strategy 类层次为Context 定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能， 策略模式的另一个优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。 当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy 类中，可以在使用这些行为的类中消除条件语句。 策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。（在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象。）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Let's Encrypt证书使用]]></title>
      <url>%2Farchives%2Fec1907ff.html</url>
      <content type="text"><![CDATA[Let’s Encrypt证书使用 certbot软件从Github直接下载，在CentOS6、7下执行都没有问题。 设置yum代码库 certbot-auto运行是会自动连接下载依赖包，启用163(http://mirrors.163.com/.help/centos.html) 和epel(https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F)库，提前准备好环境，更多查看https://certbot.eff.org/#centosrhel6-other 12341.wget http://mirrors.163.com/.help/CentOS6-Base-163.repo2.mv CentOS6-Base-163.repo /etc/yum.repos.d/3.wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm4.rpm -ivh epel-release-latest-6.noarch.rpm 修改CentOS6-Base-163.repo文件，将$releasever替换为6修改epel.repo文件，将$releasever替换为6，将http://download.fedoraproject.org/pub/epel修改为https://mirrors.tuna.tsinghua.edu.cn/epel运行以下命令生成缓存 12yum clean allyum makecache 安装git软件，也可直接从https://github.com/certbot/certbot下载1yum install git 防火墙修改修改/etc/sysconfig/iptables1vim /etc/sysconfig/iptables 查看是否有80、443端口允许访问记录12-A INPUT -i eth0 -p tcp -m tcp --dport 80 -j ACCEPT-A INPUT -i eth0 -p tcp -m tcp --dport 443 -j ACCEPT 获取Let’s Encrypt证书certbot-auto运行是会自动连接下载依赖包，执行过程出现问题具体分析原因12git clone https://github.com/certbot/certbotcd certbot certbot-auto命令在root用户下执行，certbot-auto会执行更新certbot版本和安装依赖包，执行需要联网，有时较慢1./certbot-auto certonly --standalone --email 你的邮箱 -d 你的域名 生成的证书放在/etc/letsencrypt/live/[网站域名]下，证书有效期3个月 文件名 内容 cert.pem 服务端证书 chain.pem 浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书 fullchain.pem 包括了cert.pem和chain.pem的内容 privkey.pem 证书的私钥 Apache 设置Apache测试版本 12Server version: Apache/2.4.6 (CentOS)Server built: Nov 14 2016 18:04:44 修改/etc/httpd/conf.d/ssl.conf12345678Listen 443 https&lt;VirtualHost _default_:443&gt;Header always set Strict-Transport-Security "max-age=63072000; includeSubdomains; preload"SSLEngine onSSLCertificateFile /etc/letsencrypt/live/域名/cert.pemSSLCertificateKeyFile /etc/letsencrypt/live/域名/privkey.pemSSLCertificateChainFile /etc/letsencrypt/live/域名/fullchain.pem&lt;/VirtualHost&gt; HSTS（HTTP Strict Transport Security）的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。 Tomcat设置123cp /etc/letsencrypt/live/域名/*.pem apache-tomcat-8.5.5/conf/cd apache-tomcat-8.5.5/conf/chown 用户:组 *.pem 修改conf/server.xml文件： 12345678910&lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol" maxThreads="150" SSLEnabled="true" &gt; &lt;UpgradeProtocol className="org.apache.coyote.http2.Http2Protocol" /&gt; &lt;SSLHostConfig&gt; &lt;Certificate certificateKeyFile="conf/privkey.pem" certificateFile="conf/cert.pem" certificateChainFile="conf/fullchain.pem" type="RSA" /&gt; &lt;/SSLHostConfig&gt;&lt;/Connector&gt; Nginx设置修改nginx的配置文件/usr/local/nginx/conf/nginx.conf，实现https转到内网tomcat的http服务，注：以下配置未实现tomcat识别来自https的请求，详细见问题3 1234567891011121314151617181920server &#123; listen 8443; server_name localhost; ssl on; ssl_certificate /etc/letsencrypt/live/域名/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/域名/privkey.pem; server_name_in_redirect off; proxy_set_header Host $host:$server_port; proxy_connect_timeout 60s; proxy_read_timeout 5400s; proxy_send_timeout 5400s; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; index index.html index.htm index.jsp index.do; location ^~ /ZhsqApp/&#123; proxy_pass http://192.168.100.10:8080; client_max_body_size 100m; &#125; &#125; Weblogic 配置weblogic必须是10.3.6及以上版本，才能使用Let’s Encrypt的证书，Let’s Encrypt采用SHA256withRSA，低版本的不支持SHA256withRSA 生成密钥库执行openssl命令生成fullchain_and_key.p12，执行keytool命令生成密钥库文件weblogic.jks 12openssl pkcs12 -export -in fullchain.pem -inkey privkey.pem -out fullchain_and_key.p12 -name weblogic -passout pass:123456keytool -importkeystore -deststorepass 123456 -destkeystore weblogic.jks -srckeystore fullchain_and_key.p12 -srcstoretype PKCS12 -srcstorepass 123456 -alias weblogic privkey.pem、fullchain.pem为Let’s Encrypt生成文件，密码可自行修改。注-name与-alias别名保存一致，-passout参数的pass:需保留。-passout与-srcstorepass密码保持一致， -deststorepass需记住在weblogic配置使用。 生成信任库执行keytool命令生成信任库文件trust.jks1keytool -importcert -alias rootCA -trustcacerts -file cert.pem -keystore trust.jks -storepass 123456 cert.pem为Let’s Encrypt生成文件，密码可自行修改。 -storepass需记住在weblogic配置使用。 weblogic配置启用SSL监听端口登录weblogic控制台 -&gt; 服务器 -&gt; 选择服务器管理 -&gt; 配置标签 -&gt; 一般信息子标签页 -&gt; 启用 SSL 监听端口 -&gt; 修改端口7002 -&gt; 保存 在Linux下设置端口小于1024的，需要使用管理员用户启动weblogic。 密钥库配置进入配置标签 -&gt; 密钥库标签页 1.密钥库点更改，选择定制标识和定制信任，点击保存。2.定制标识密钥库，填写weblogic.jks全路径定制标识密钥库类型，填写jks3.定制标识密钥库密码短语，填写生成密钥库时 -deststorepass写的密码4.确认定制标识密钥库密码短语，填写生成密钥库时 -deststorepass写的密码5.定制信任密钥库，填写trust.jks全路径6.定制信任密钥库类型，填写jks7.定制信任密钥库密码短语，填写生成信任库时 -storepass写的密码8.确认定制信任密钥库密码短语，填写生成信任库时 -storepass写的密码 SSL配置进入配置标签 -&gt; SSL标签页 1.私有密钥别名，填写生成密钥库时的别名2.私有密钥密码短语，填写生成密钥库时 -deststorepass写的密码3.确认私有密钥密码短语，填写生成密钥库时 -deststorepass写的密码点击保存 weblogic 10.3. 6 版本还需要做额外配置，SSL标签页中，点击高级，选中使用 JSSE SSL，点击保存 重启weblogic服务，测试https访问。 更新证书1./certbot-auto renew 更新证书之后，需要执行tomcat、weblogic对应配置内容。 问题问题1、Let’s Encrypt安装好之后在PC端可以正常访问，但在手机端提示不受信任的主要原因是缺少中级证书。生成的LE证书后使用的需要使用fullchain.pem，打开后会发现有两段证书，第一段是LE的证书，第二段才是你网站的证书。而你只有网站的证书，而没有LE的证书。 问题2、如何关闭SSL3协议查看http://disablessl3.com如何关闭apache、nginx的ssl3协议tomcat修改，修改server.xml, 123&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; sslProtocol=&quot;TLS&quot; sslEnabledProtocols=&quot;TLSv1,TLSv1.1,TLSv1.2&quot; &gt; 问题3、nginx采用Let’s Encrypt证书，如何实现https转http，后端识别来自https的请求1.修改nginx的配置文件修改nginx的配置文件/usr/local/nginx/conf/nginx.conf，实现https转到内网tomcat的http服务，注：以下配置未实现tomcat识别来自https的请求，详细见问题2 1234567891011121314151617181920212223server &#123; listen 8443; server_name localhost; ssl on; ssl_certificate /etc/letsencrypt/live/域名/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/域名/privkey.pem; server_name_in_redirect off; proxy_set_header Host $host:$server_port; proxy_connect_timeout 60s; proxy_read_timeout 5400s; proxy_send_timeout 5400s; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header WL-Proxy-SSL true; add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains; &quot;; index index.html index.htm index.jsp index.do; location ^~ /ZhsqApp/&#123; proxy_pass http://192.168.100.10:8080; client_max_body_size 100m; &#125; &#125; 主要增加3处配置： proxy_set_header X-Forwarded-Proto $scheme; tomcat可识别参数proxy_set_header WL-Proxy-SSL true; weblogic可识别参数add_header Strict-Transport-Security “max-age=63072000; includeSubdomains; “; 启用HSTS功能，浏览器在63072000秒时间内默认以https请求服务 2.tomcat启用识别X-Forwarded-Proto设置修改配置文件server.xml，在Engine下添加下面内容 123&lt;Valve className=&quot;org.apache.catalina.valves.RemoteIpValve&quot; remoteIpHeader=&quot;X-Forwarded-For&quot; protocolHeader=&quot;X-Forwarded-Proto&quot; protocolHeaderHttpsValue=&quot;https&quot;/&gt; 做好上述配置，重启tomcat。request.getScheme()的值显示https另外，可参考Nginx SSL+tomcat集群,request.getScheme() 取到https正确的协议内容 3.weblogic启用识别WL-Proxy-SSL 设置进入console界面，域名-&gt;配置-&gt;Web应用程序，勾选启用 WebLogic 插件，保存 做好上述配置，重启weblogic。request.getScheme()的值显示https另外，可参考HTTPS/SSL/Spring Security doesn’t work in both a load balancer and non-load balancer environment #424内容]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring ioc 控制反转]]></title>
      <url>%2Farchives%2F50de3585.html</url>
      <content type="text"><![CDATA[Spring – IOCspring ioc 控制反转IOC（Inversion of Control）控制反转：本来是由应用程序管理的对象之间的依赖关系，现在交给了容器管理，这就叫控制反转，即交给了IOC容器，Spring的IOC容器主要使用DI方式实现的。不需要主动查找，对象的查找、定位和创建全部由容器管理。 通俗点说就是不创建对象。以前我们要调用一个对象的方法，首先要new一个对象。但使用IOC容器，在代码中不直接与对象连接，而是在配置文件中描述要使用哪一个对象。容器负责将这些联系在一起。 实现方法IOC容器的对象实例化是通过配置文件来实现的。术语上这叫做注入。注入有两种形式，采用构造方法注入和采用setter注入。具体的注入形式如下 采用set方法注入，给属性添加一个set方法，并对其进行赋值1234567891011publicclass UserManagerImplimplements UserManager &#123; private UserDaouserDao; publicvoid setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125; 配置文件：12345&lt;beanid="userManager"class="com.bjpowernode.spring.manager.UserManagerImpl"&gt; &lt;propertyname="userDao"ref="usrDao4Oracle"/&gt; &lt;/bean&gt; set注入特点： 与传统的JavaBean的写法更相似，程序员更容易理解、接受，通过setter方式设定依赖关系显得更加直观、明显； 对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致死你功能下降。而使用设置注入，则避免这下问题； 尤其在某些属性可选的情况下，多参数的构造器更加笨拙。 采用构造方法注入，在构造方法中对属性进行赋值12345678publicclass UserManagerImplimplements UserManager &#123; private UserDaouserDao; public UserManagerImpl(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125; 配置文件：12345&lt;beanid="userManager"class="com.bjpowernode.spring.manager.UserManagerImpl"&gt; &lt;constructor-argref="userDao4Mysql"/&gt;&lt;/bean&gt; 构造方法注入特点： 构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。 对于依赖关系无须变化的Bean，构造注入更有用处；因为没有setter方法，所有的依赖关系全部在构造器内设定，因此，不用担心后续代码对依赖关系的破坏。 依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系。对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之promise]]></title>
      <url>%2Farchives%2Ffddbb00f.html</url>
      <content type="text"><![CDATA[js学习之promisePromise的初步认识我们之前在完成异步执行都是利用的回调函数去实现的，例如ajax的调用：12345678910111213141516171819202122var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调 if (request.readyState === 4) &#123; // 成功完成 // 判断响应结果: if (request.status === 200) &#123; // 成功，通过responseText拿到响应的文本: return success(request.responseText); &#125; else &#123; // 失败，根据响应码判断失败原因: return fail(request.status); &#125; &#125; else &#123; // HTTP请求还在继续... &#125;&#125;// 发送请求:request.open('GET', '/api/categories');request.send();alert('请求已发送，请等待响应...'); 当然我们可以封装起来，改成另外的写法：123var ajax = ajaxGet('http://...');ajax.ifSuccess(success) .ifFail(fail); 但是我们从ES6后我们有了新的写法 12345new Promise(test).then(function (result) &#123; console.log('成功：' + result);&#125;).catch(function (reason) &#123; console.log('失败：' + reason);&#125;); 当然这只是简单的promise的利用，进阶版本请看参考链接。 参考链接&gt;1.Promise - 廖雪峰的官方网站2.[翻译] We have a problem with promises - FEX3.JavaScript Promise迷你书（中文版） 前方的路很长，还需努力啊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[travis部署Hexo之填坑日记]]></title>
      <url>%2Farchives%2Fa8653e18.html</url>
      <content type="text"><![CDATA[这个小客栈总算是被我搭起来了，前前后后遇到了不少坑。果然每一次在网上学东西都是遇坑填坑的过程，不过这都是为了我们更好的成（zhuang）长(bi)嘛。 也就不重复的讲其他教程里有的内容了，只简明的记录下，我的填坑过程。 第一个坑 travis 找不指定文件 123$ cd 博客项目文件夹根目录$ touch .travis.yml 登录 travis 12travis login --auto` 123# 这里的 REPO_TOKEN 是变量名,在后面的配置文件中会用到# TOKEN 是上面github生成的Tokentravis encrypt 'REPO_TOKEN=&lt;TOKEN&gt;' --add 这在很多讲解Travis部署Hexo的教程中都有的步骤，那么问题就出现了。。。。 travis 找不到指定文件 这里是在travis encrypt 你的github创建的token的时候出现的。 解决办法： 在travis encrypt ‘REPO_TOKEN=‘ –add 的时候加上 -r 你的github用户民/你的repo名。比如我的就是 1travis encrypt 'REPO_TOKEN=&lt;TOKEN&gt;' --add -r Nanmen/nanmen.github.io 第二个坑 travis 构建你的工程时报2&gt; dev/null错的问题 当我兴高采烈的去推送到我的dev分支的时候，travis 运行测试过程中报出个 ‘\ 2&gt;dev/null’ 的错误，一脸懵有没有，明明都是按照教程来的，怎么会是这样的呢。在我前后回想之后，一不小心测试出来了。。。。 解决办法： 在你执行travis encrypt 的时候，并不是跟大部分教程写的那样，应该执行这一句1travis encrypt REPO_TOKEN=TOKEN --add -r Nanmen/nanmen.github.io 参考资料1.手把手教从零开始在GitHub上使用Hexo搭建博客教程(一)-附GitHub注册及配置 - 简书 2.手把手教从零开始在GitHub上使用Hexo搭建博客教程(四)-使用Travis自动部署Hex… - 简书 3.hexo教程系列——使用Travis自动部署hexo - 张学志の博客 - 博客频道 - CSDN.NET]]></content>
    </entry>

    
  
  
</search>
