<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[记推送失败——git命令之ssh-add学习]]></title>
      <url>%2Farchives%2Fe8996bd7.html</url>
      <content type="text"><![CDATA[推送失败——git命令学习起因昨天更新文档推送设计模式的笔记，在git bash 命令框下输入以前的 1hexo g -d 却给我报了个错误,Could not open a connection to your authentication agent，一翻百度发现解决方法如下： 1.exec ssh-agent bash2.eval ssh-agent -s3.ssh-add “C:\Users\Administrator.ssh\id_rsa” 将相应的秘钥地址改为你自己的地址，然后就可以愉快的输入测试命令了 12ssh -T git@github.comssh -T git@git.coding.net 测试通过，ok，然后就可以输入部署命令了。 参考文档 win下给 Git Bash 添加私钥时ssh-add报错的解决办法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[大话设计模式——读后感（2）]]></title>
      <url>%2Farchives%2Fd1e9f0a5.html</url>
      <content type="text"><![CDATA[大话设计模式——读后感（2）Tip2备忘录模式 备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 Originator（发起人）：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。 Originator可根据需要决定Memento存储Originator的哪些内部状态 Memento（备忘录）：负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。 备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到 先前状态所需的所有数据。 Caretaker（管理者）：负责保存好备忘录Memento，不能对备忘录的内存进行操作或检查。 备忘录模式代码实现以一个Emp实体对象来作为例子 首先，创建一个发起人：发起人内部保存着需要备忘的属性，它负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。 123456789101112131415161718//发起人：发起人内部有自身的内部状态，并且发起人可以创建备忘录和恢复备忘录public class EmpOriginator &#123; //需要备份的自身属性 private String ename; private int age; private double salary; //备份 public EmpMemento memento()&#123; return new EmpMemento(this);//将当前自身对象备份 &#125; //恢复 public void recovery(EmpMemento emp)&#123; this.ename = emp.getEname(); this.age = emp.getAge(); this.salary = emp.getSalary(); &#125; //省略get，set和带参构造器&#125; 创建备忘录对象：备忘录就是用来备份发起人的数据，所以构造器需要提供一个发起人对象 1234567891011121314//备忘录对象public class EmpMemento &#123; //自身属性 private String ename; private int age; private double salary; //构造备忘录对象时，需要传入一个需要备忘的对象（发起人） public EmpMemento(EmpOriginator emp) &#123; this.ename = emp.getEname(); this.age = emp.getAge(); this.salary = emp.getSalary(); &#125; //省略3个属性的set,get方法&#125; 开始创建一个备忘录的管理者 1234567891011//管理者：管理备忘录对象public class CareTaker &#123; //需要管理的备忘录对象，这里也可以使用一个list容器来存储。这样可以备份多个点 private EmpMemento empMemento; public EmpMemento getEmpMemento() &#123; return empMemento; &#125; public void setEmpMemento(EmpMemento empMemento) &#123; this.empMemento = empMemento; &#125;&#125; 单次备份测试：测试只能备份一次的备忘录 12345678910111213141516171819public static void main(String[] args) &#123; CareTaker taker = new CareTaker();//构建一个备忘录管理者 //构建发起人 EmpOriginator emp = new EmpOriginator("张三", 20, 4000); System.out.println("第一次："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary()); //备份 taker.setEmpMemento(emp.memento()); //备份完了后再修改 emp.setEname("李四"); emp.setAge(30); emp.setSalary(50000); //然后再次打印 System.out.println("修改后："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary()); //开始恢复 emp.recovery(taker.getEmpMemento()); System.out.println("恢复后："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary());&#125; 测试结果如下： 第一次：张三---20---4000.0 修改后：李四---30---50000.0 恢复后：张三---20---4000.0 但是，这样的效果是只能备份一次。有时候我们需要备份多个点，根据需要来还原具体哪次的数据 多次备份使用Stack来存储备份数据，进行多次备份。用Stack的好处是Stack是后进先出的，也就是说：你最近一次备份的数据会优先获取到。 修改管理者中的代码： 12345678910111213141516171819202122232425262728import java.util.Stack;//管理者：管理备忘录对象public class CareTaker &#123; //需要管理的备忘录对象，这里也可以使用一个list容器来存储。这样可以备份多个点 //或者使用一个Stack栈来保存，因为Stack是后进先出的 private Stack&lt;EmpMemento&gt; stack = new Stack&lt;EmpMemento&gt;(); //备份emp数据到栈中 public void mementoEmp(EmpMemento emp)&#123; stack.push(emp); &#125; //从栈中获取最近一次备份的emp数据 public EmpMemento getEmpForStack()&#123; if (!stack.empty()) &#123; return stack.peek();//peek只获取，不删除 &#125;else&#123; return null; &#125; &#125; //从栈中获取最近一次备份的emp数据,并且从栈中删除该数据 public EmpMemento getEmpForStackAndRemove()&#123; if (!stack.empty()) &#123; return stack.pop();//pop获取后删除该元素 &#125;else&#123; return null; &#125; &#125;&#125; 再次测试：后进先出，也就是说。恢复的话恢复的是最后一次备份的数据 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) &#123; CareTaker taker = new CareTaker();//构建一个备忘录管理者 //构建发起人 EmpOriginator emp = new EmpOriginator("张三", 20, 4000); System.out.println("第一次："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary()); //第1次备份 taker.mementoEmp(emp.memento()); //备份完了后再修改 emp.setEname("李四"); emp.setAge(30); emp.setSalary(50000); //然后再次打印 System.out.println("1修改后："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary()); //第2次备份 taker.mementoEmp(emp.memento()); //备份完了后再修改 emp.setEname("李四2"); emp.setAge(32); emp.setSalary(52000); //然后再次打印 System.out.println("2修改后："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary()); //第3次备份 taker.mementoEmp(emp.memento()); //备份完了后再修改 emp.setEname("李四3"); emp.setAge(33); emp.setSalary(32000); //然后再次打印 System.out.println("3修改后："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary()); //第4次备份 taker.mementoEmp(emp.memento()); //开始恢复 emp.recovery(taker.getEmpForStack());//恢复的是第4次备份的数据（3修改后） System.out.println("恢复后："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary());&#125; 测试结果如下： 第一次：张三---20---4000.0 1修改后：李四---30---50000.0 2修改后：李四2---32---52000.0 3修改后：李四3---33---32000.0 恢复后：李四3---33---32000.0 当然，也可以恢复之后把它从栈中删除。 测试：恢复之前从栈中删除两个最近的数据 12345//开始恢复taker.getEmpForStackAndRemove();//删除最近一次的备份taker.getEmpForStackAndRemove();//删除最近一次的备份emp.recovery(taker.getEmpForStack());//此时获取的是原来未删除时倒数第二次的备份System.out.println("恢复后："+emp.getEname()+"---"+emp.getAge()+"---"+emp.getSalary()); 此时的结果就是如下：可见，这里已经把2和3给删除了 第一次：张三---20---4000.0 1修改后：李四---30---50000.0 2修改后：李四2---32---52000.0 3修改后：李四3---33---32000.0 恢复后：李四---30---50000.0 总结-应用场景 棋类游戏中的悔棋操作 软件中的撤销操作 数据库中的事务回滚操作 常用软件中的历史记录功能 参考资料 大话设计模式(带目录完整版).pdf 备忘录模式（Memento） - FangZheng - 博客园]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新的开始]]></title>
      <url>%2Farchives%2Fb585e161.html</url>
      <content type="text"><![CDATA[新的开始初整理 —— 大话设计模式Tip1 读后笔记UML类图整理 动物类 (‘+’ 表示public ，’-‘ 表示private，’#’表示protected) 第一层类的名称 (抽象类是用斜体表示) 第二层类的特性 第三层类的函数方法 飞翔 接口图 顶层是\&lt;&gt;显示 第二层是方法 另一种接口表现法是棒棒糖表示法（表现的唐老鸭实现了‘讲人话’的方法）。 继承：空心三角形+实线 表示。 实现：空心三角形+虚线 表示。 关联：实线箭头 表示。 聚合：空心的菱形+实线箭头 表示。（聚合表示一种弱的‘拥有关系’，体现的是A对象可以包含B对象，但B对象不是A对象的一部分[DPE]） 合成：菱形+实线箭头，两端数字为基数，表示一端的类可以有几个实例。（合成是一种强的拥有关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样） 依赖：虚线箭头表示。 简单工厂模式简单工厂模式：用一个单独的类来做这个创造实例的过程。 策略模式策略模式：是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。 策略模式的Strategy 类层次为Context 定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能， 策略模式的另一个优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。 当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy 类中，可以在使用这些行为的类中消除条件语句。 策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。（在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象。）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Let's Encrypt证书使用]]></title>
      <url>%2Farchives%2Fec1907ff.html</url>
      <content type="text"><![CDATA[Let’s Encrypt证书使用 certbot软件从Github直接下载，在CentOS6、7下执行都没有问题。 设置yum代码库 certbot-auto运行是会自动连接下载依赖包，启用163(http://mirrors.163.com/.help/centos.html) 和epel(https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F)库，提前准备好环境，更多查看https://certbot.eff.org/#centosrhel6-other 12341.wget http://mirrors.163.com/.help/CentOS6-Base-163.repo2.mv CentOS6-Base-163.repo /etc/yum.repos.d/3.wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm4.rpm -ivh epel-release-latest-6.noarch.rpm 修改CentOS6-Base-163.repo文件，将$releasever替换为6修改epel.repo文件，将$releasever替换为6，将http://download.fedoraproject.org/pub/epel修改为https://mirrors.tuna.tsinghua.edu.cn/epel运行以下命令生成缓存 12yum clean allyum makecache 安装git软件，也可直接从https://github.com/certbot/certbot下载1yum install git 防火墙修改修改/etc/sysconfig/iptables1vim /etc/sysconfig/iptables 查看是否有80、443端口允许访问记录12-A INPUT -i eth0 -p tcp -m tcp --dport 80 -j ACCEPT-A INPUT -i eth0 -p tcp -m tcp --dport 443 -j ACCEPT 获取Let’s Encrypt证书certbot-auto运行是会自动连接下载依赖包，执行过程出现问题具体分析原因12git clone https://github.com/certbot/certbotcd certbot certbot-auto命令在root用户下执行，certbot-auto会执行更新certbot版本和安装依赖包，执行需要联网，有时较慢1./certbot-auto certonly --standalone --email 你的邮箱 -d 你的域名 生成的证书放在/etc/letsencrypt/live/[网站域名]下，证书有效期3个月 文件名 内容 cert.pem 服务端证书 chain.pem 浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书 fullchain.pem 包括了cert.pem和chain.pem的内容 privkey.pem 证书的私钥 Apache 设置Apache测试版本 12Server version: Apache/2.4.6 (CentOS)Server built: Nov 14 2016 18:04:44 修改/etc/httpd/conf.d/ssl.conf12345678Listen 443 https&lt;VirtualHost _default_:443&gt;Header always set Strict-Transport-Security "max-age=63072000; includeSubdomains; preload"SSLEngine onSSLCertificateFile /etc/letsencrypt/live/域名/cert.pemSSLCertificateKeyFile /etc/letsencrypt/live/域名/privkey.pemSSLCertificateChainFile /etc/letsencrypt/live/域名/fullchain.pem&lt;/VirtualHost&gt; HSTS（HTTP Strict Transport Security）的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。 Tomcat设置123cp /etc/letsencrypt/live/域名/*.pem apache-tomcat-8.5.5/conf/cd apache-tomcat-8.5.5/conf/chown 用户:组 *.pem 修改conf/server.xml文件： 12345678910&lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol" maxThreads="150" SSLEnabled="true" &gt; &lt;UpgradeProtocol className="org.apache.coyote.http2.Http2Protocol" /&gt; &lt;SSLHostConfig&gt; &lt;Certificate certificateKeyFile="conf/privkey.pem" certificateFile="conf/cert.pem" certificateChainFile="conf/fullchain.pem" type="RSA" /&gt; &lt;/SSLHostConfig&gt;&lt;/Connector&gt; Nginx设置修改nginx的配置文件/usr/local/nginx/conf/nginx.conf，实现https转到内网tomcat的http服务，注：以下配置未实现tomcat识别来自https的请求，详细见问题3 1234567891011121314151617181920server &#123; listen 8443; server_name localhost; ssl on; ssl_certificate /etc/letsencrypt/live/域名/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/域名/privkey.pem; server_name_in_redirect off; proxy_set_header Host $host:$server_port; proxy_connect_timeout 60s; proxy_read_timeout 5400s; proxy_send_timeout 5400s; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; index index.html index.htm index.jsp index.do; location ^~ /ZhsqApp/&#123; proxy_pass http://192.168.100.10:8080; client_max_body_size 100m; &#125; &#125; Weblogic 配置weblogic必须是10.3.6及以上版本，才能使用Let’s Encrypt的证书，Let’s Encrypt采用SHA256withRSA，低版本的不支持SHA256withRSA 生成密钥库执行openssl命令生成fullchain_and_key.p12，执行keytool命令生成密钥库文件weblogic.jks 12openssl pkcs12 -export -in fullchain.pem -inkey privkey.pem -out fullchain_and_key.p12 -name weblogic -passout pass:123456keytool -importkeystore -deststorepass 123456 -destkeystore weblogic.jks -srckeystore fullchain_and_key.p12 -srcstoretype PKCS12 -srcstorepass 123456 -alias weblogic privkey.pem、fullchain.pem为Let’s Encrypt生成文件，密码可自行修改。注-name与-alias别名保存一致，-passout参数的pass:需保留。-passout与-srcstorepass密码保持一致， -deststorepass需记住在weblogic配置使用。 生成信任库执行keytool命令生成信任库文件trust.jks1keytool -importcert -alias rootCA -trustcacerts -file cert.pem -keystore trust.jks -storepass 123456 cert.pem为Let’s Encrypt生成文件，密码可自行修改。 -storepass需记住在weblogic配置使用。 weblogic配置启用SSL监听端口登录weblogic控制台 -&gt; 服务器 -&gt; 选择服务器管理 -&gt; 配置标签 -&gt; 一般信息子标签页 -&gt; 启用 SSL 监听端口 -&gt; 修改端口7002 -&gt; 保存 在Linux下设置端口小于1024的，需要使用管理员用户启动weblogic。 密钥库配置进入配置标签 -&gt; 密钥库标签页 1.密钥库点更改，选择定制标识和定制信任，点击保存。2.定制标识密钥库，填写weblogic.jks全路径定制标识密钥库类型，填写jks3.定制标识密钥库密码短语，填写生成密钥库时 -deststorepass写的密码4.确认定制标识密钥库密码短语，填写生成密钥库时 -deststorepass写的密码5.定制信任密钥库，填写trust.jks全路径6.定制信任密钥库类型，填写jks7.定制信任密钥库密码短语，填写生成信任库时 -storepass写的密码8.确认定制信任密钥库密码短语，填写生成信任库时 -storepass写的密码 SSL配置进入配置标签 -&gt; SSL标签页 1.私有密钥别名，填写生成密钥库时的别名2.私有密钥密码短语，填写生成密钥库时 -deststorepass写的密码3.确认私有密钥密码短语，填写生成密钥库时 -deststorepass写的密码点击保存 weblogic 10.3. 6 版本还需要做额外配置，SSL标签页中，点击高级，选中使用 JSSE SSL，点击保存 重启weblogic服务，测试https访问。 更新证书1./certbot-auto renew 更新证书之后，需要执行tomcat、weblogic对应配置内容。 问题问题1、Let’s Encrypt安装好之后在PC端可以正常访问，但在手机端提示不受信任的主要原因是缺少中级证书。生成的LE证书后使用的需要使用fullchain.pem，打开后会发现有两段证书，第一段是LE的证书，第二段才是你网站的证书。而你只有网站的证书，而没有LE的证书。 问题2、如何关闭SSL3协议查看http://disablessl3.com如何关闭apache、nginx的ssl3协议tomcat修改，修改server.xml, 123&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; sslProtocol=&quot;TLS&quot; sslEnabledProtocols=&quot;TLSv1,TLSv1.1,TLSv1.2&quot; &gt; 问题3、nginx采用Let’s Encrypt证书，如何实现https转http，后端识别来自https的请求1.修改nginx的配置文件修改nginx的配置文件/usr/local/nginx/conf/nginx.conf，实现https转到内网tomcat的http服务，注：以下配置未实现tomcat识别来自https的请求，详细见问题2 1234567891011121314151617181920212223server &#123; listen 8443; server_name localhost; ssl on; ssl_certificate /etc/letsencrypt/live/域名/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/域名/privkey.pem; server_name_in_redirect off; proxy_set_header Host $host:$server_port; proxy_connect_timeout 60s; proxy_read_timeout 5400s; proxy_send_timeout 5400s; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header WL-Proxy-SSL true; add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains; &quot;; index index.html index.htm index.jsp index.do; location ^~ /ZhsqApp/&#123; proxy_pass http://192.168.100.10:8080; client_max_body_size 100m; &#125; &#125; 主要增加3处配置： proxy_set_header X-Forwarded-Proto $scheme; tomcat可识别参数proxy_set_header WL-Proxy-SSL true; weblogic可识别参数add_header Strict-Transport-Security “max-age=63072000; includeSubdomains; “; 启用HSTS功能，浏览器在63072000秒时间内默认以https请求服务 2.tomcat启用识别X-Forwarded-Proto设置修改配置文件server.xml，在Engine下添加下面内容 123&lt;Valve className=&quot;org.apache.catalina.valves.RemoteIpValve&quot; remoteIpHeader=&quot;X-Forwarded-For&quot; protocolHeader=&quot;X-Forwarded-Proto&quot; protocolHeaderHttpsValue=&quot;https&quot;/&gt; 做好上述配置，重启tomcat。request.getScheme()的值显示https另外，可参考Nginx SSL+tomcat集群,request.getScheme() 取到https正确的协议内容 3.weblogic启用识别WL-Proxy-SSL 设置进入console界面，域名-&gt;配置-&gt;Web应用程序，勾选启用 WebLogic 插件，保存 做好上述配置，重启weblogic。request.getScheme()的值显示https另外，可参考HTTPS/SSL/Spring Security doesn’t work in both a load balancer and non-load balancer environment #424内容]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring ioc 控制反转]]></title>
      <url>%2Farchives%2F50de3585.html</url>
      <content type="text"><![CDATA[Spring – IOCspring ioc 控制反转IOC（Inversion of Control）控制反转：本来是由应用程序管理的对象之间的依赖关系，现在交给了容器管理，这就叫控制反转，即交给了IOC容器，Spring的IOC容器主要使用DI方式实现的。不需要主动查找，对象的查找、定位和创建全部由容器管理。 通俗点说就是不创建对象。以前我们要调用一个对象的方法，首先要new一个对象。但使用IOC容器，在代码中不直接与对象连接，而是在配置文件中描述要使用哪一个对象。容器负责将这些联系在一起。 实现方法IOC容器的对象实例化是通过配置文件来实现的。术语上这叫做注入。注入有两种形式，采用构造方法注入和采用setter注入。具体的注入形式如下 采用set方法注入，给属性添加一个set方法，并对其进行赋值1234567891011publicclass UserManagerImplimplements UserManager &#123; private UserDaouserDao; publicvoid setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125; 配置文件：12345&lt;beanid="userManager"class="com.bjpowernode.spring.manager.UserManagerImpl"&gt; &lt;propertyname="userDao"ref="usrDao4Oracle"/&gt; &lt;/bean&gt; set注入特点： 与传统的JavaBean的写法更相似，程序员更容易理解、接受，通过setter方式设定依赖关系显得更加直观、明显； 对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致死你功能下降。而使用设置注入，则避免这下问题； 尤其在某些属性可选的情况下，多参数的构造器更加笨拙。 采用构造方法注入，在构造方法中对属性进行赋值12345678publicclass UserManagerImplimplements UserManager &#123; private UserDaouserDao; public UserManagerImpl(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125; 配置文件：12345&lt;beanid="userManager"class="com.bjpowernode.spring.manager.UserManagerImpl"&gt; &lt;constructor-argref="userDao4Mysql"/&gt;&lt;/bean&gt; 构造方法注入特点： 构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。 对于依赖关系无须变化的Bean，构造注入更有用处；因为没有setter方法，所有的依赖关系全部在构造器内设定，因此，不用担心后续代码对依赖关系的破坏。 依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系。对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js学习之promise]]></title>
      <url>%2Farchives%2Ffddbb00f.html</url>
      <content type="text"><![CDATA[js学习之promisePromise的初步认识我们之前在完成异步执行都是利用的回调函数去实现的，例如ajax的调用：12345678910111213141516171819202122var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调 if (request.readyState === 4) &#123; // 成功完成 // 判断响应结果: if (request.status === 200) &#123; // 成功，通过responseText拿到响应的文本: return success(request.responseText); &#125; else &#123; // 失败，根据响应码判断失败原因: return fail(request.status); &#125; &#125; else &#123; // HTTP请求还在继续... &#125;&#125;// 发送请求:request.open('GET', '/api/categories');request.send();alert('请求已发送，请等待响应...'); 当然我们可以封装起来，改成另外的写法：123var ajax = ajaxGet('http://...');ajax.ifSuccess(success) .ifFail(fail); 但是我们从ES6后我们有了新的写法 12345new Promise(test).then(function (result) &#123; console.log('成功：' + result);&#125;).catch(function (reason) &#123; console.log('失败：' + reason);&#125;); 当然这只是简单的promise的利用，进阶版本请看参考链接。 参考链接&gt;1.Promise - 廖雪峰的官方网站2.[翻译] We have a problem with promises - FEX3.JavaScript Promise迷你书（中文版） 前方的路很长，还需努力啊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[travis部署Hexo之填坑日记]]></title>
      <url>%2Farchives%2Fa8653e18.html</url>
      <content type="text"><![CDATA[这个小客栈总算是被我搭起来了，前前后后遇到了不少坑。果然每一次在网上学东西都是遇坑填坑的过程，不过这都是为了我们更好的成（zhuang）长(bi)嘛。 也就不重复的讲其他教程里有的内容了，只简明的记录下，我的填坑过程。 第一个坑 travis 找不指定文件 12$ cd 博客项目文件夹根目录$ touch .travis.yml 登录 travis12travis login --auto` 123# 这里的 REPO_TOKEN 是变量名,在后面的配置文件中会用到# TOKEN 是上面github生成的Tokentravis encrypt 'REPO_TOKEN=&lt;TOKEN&gt;' --add 这在很多讲解Travis部署Hexo的教程中都有的步骤，那么问题就出现了。。。。 travis 找不到指定文件 这里是在travis encrypt 你的github创建的token的时候出现的。 解决办法： 在travis encrypt ‘REPO_TOKEN=‘ –add 的时候加上 -r 你的github用户民/你的repo名。比如我的就是 1travis encrypt 'REPO_TOKEN=&lt;TOKEN&gt;' --add -r Nanmen/nanmen.github.io 第二个坑 travis 构建你的工程时报2&gt; dev/null错的问题 当我兴高采烈的去推送到我的dev分支的时候，travis 运行测试过程中报出个 ‘\ 2&gt;dev/null’ 的错误，一脸懵有没有，明明都是按照教程来的，怎么会是这样的呢。在我前后回想之后，一不小心测试出来了。。。。 解决办法： 在你执行travis encrypt 的时候，并不是跟大部分教程写的那样，应该执行这一句1travis encrypt REPO_TOKEN=TOKEN --add -r Nanmen/nanmen.github.io 参考资料1.手把手教从零开始在GitHub上使用Hexo搭建博客教程(一)-附GitHub注册及配置 - 简书 2.手把手教从零开始在GitHub上使用Hexo搭建博客教程(四)-使用Travis自动部署Hex… - 简书 3.hexo教程系列——使用Travis自动部署hexo - 张学志の博客 - 博客频道 - CSDN.NET]]></content>
    </entry>

    
  
  
</search>
