<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>在路上 - easy life</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ymjava.cn/"/>
  <updated>2018-02-24T07:35:26.829Z</updated>
  <id>http://ymjava.cn/</id>
  
  <author>
    <name>南风</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java23种设计模式概括</title>
    <link href="http://ymjava.cn/archives/5c9c5ce0.html"/>
    <id>http://ymjava.cn/archives/5c9c5ce0.html</id>
    <published>2018-02-24T03:06:09.000Z</published>
    <updated>2018-02-24T07:35:26.829Z</updated>
    
    <content type="html"><![CDATA[<p>##<center>java 23种设计模式概括</center></p>
<h3 id="目录概览"><a href="#目录概览" class="headerlink" title="目录概览"></a>目录概览</h3><h4 id="创建型模式：关注对象的创建过程"><a href="#创建型模式：关注对象的创建过程" class="headerlink" title="创建型模式：关注对象的创建过程"></a>创建型模式：关注对象的创建过程</h4><ul>
<li><p><a href="http://www.cnblogs.com/meet/p/5116398.html" target="_blank" rel="external">单例模式</a>：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点<br>主要：<br>饿汉式（线程安全，调用效率高，但是不能延时加载）<br>懒汉式（线程安全，调用效率不高，但是可以延时加载）<br>其他：<br>双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）<br>静态内部类式（线程安全，调用效率高。但是可以延时加载）<br>枚举单例（线程安全，调用效率高，不能延时加载）</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116400.html" target="_blank" rel="external">工厂模式</a>：<br>简单工厂模式：用来生产同一等级结构中的任意产品（对已有产品新增功能，需要修改源代码）<br>虽然能通过工厂来创建对象，但是违反了开闭原则。一旦增加功能需要在原有基础上修改代码。<br>工厂方法模式：用来生产同一等级结构中的固定产品（支持增加任意产品，不用修改源代码）<br>将工厂类调整为工厂接口，需要什么类型的工厂就使用该类实现该工厂，创建相应的产品。</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116400.html" target="_blank" rel="external">抽象工厂模式</a>：用来生产不同产品族的全部产品（对于增加新的产品，无能为力。可增加一系列的产品族）抽象工厂模式用来生产不同产品族的全部产品，对于只增加产品某一部分则不适用。抽象工厂模式是工厂模式的一种升级版本。</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116401.html" target="_blank" rel="external">建造者​模式</a>：分离了对象子组件的单独构造（由Builder来负责构建，由Director来负责组装），从而可以构造出复杂的对象。<br>假如一个对象的构建很复杂，需要很多步骤。如果使用了建造者模式，会将其构建对象，和组装成一个对象这两步给分开来构建部分为（builder）和组织部分（director），实现了构建和装配的解耦。</p>
<a id="more"></a>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116404.html" target="_blank" rel="external">原型模式</a>：通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。<br>所谓原型模式就是构建一个对象的原型，通过原型来创建出新的对象。</p>
</li>
</ul>
<h4 id="行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。"><a href="#行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。" class="headerlink" title="行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。"></a>行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。</h4><ul>
<li><p><a href="http://www.cnblogs.com/meet/p/5116417.html" target="_blank" rel="external">模板方法模式</a>：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的<br>某些特定步骤。也就是说：假如某些操作代码基本相同，只是其中一部分会经常改变，则可以使用模板方法，将不变的部分作为一个模板，将容易变动的部分让子类来实现。</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116430.html" target="_blank" rel="external">命令模式</a>（不常用）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志。以及支持可撤销的操作。说白了，就是将一系列的请求命令封装起来，不直接调用真正执行者的方法，这样比较好扩展。</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116437.html" target="_blank" rel="external">迭代器模式</a>：提供一种方法顺序的访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。也就是开发一个用于迭代某个对象中元素的功能。</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116411.html" target="_blank" rel="external">观察者模式</a>：也叫（发布-订阅模式）定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象。使它们能够自动更新自己。例如：发广播，游戏中大喇叭，群聊。jdk中提供了抽象主题和抽象观察者的接口，我们可以使用这两个接口来方便的定义自己的观察者模式</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116432.html" target="_blank" rel="external">中介者模式</a>：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用。从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式核心：1.就是将网状结构处理成星型结构 2.将多对多处理成一对多</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116407.html" target="_blank" rel="external">备忘录模式</a>：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。也就是说，不破坏源数据的情况下，将源数据进行一次或者多次的备份。</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116424.html" target="_blank" rel="external">解释器模式</a>（不常用）：给定一个语言，定义它的文法一种表示。并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116415.html" target="_blank" rel="external">状态模式</a>：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。当遇到不同的状态遇到不同的行为的时候，可以使用状态模式。例如：酒店房间的状态，是空闲，预定，还是已入住呢？而且这三种状态都对应着不同的行为，空闲的话就可预定，可预定的话就可入住，已入住的话就不能显示空闲。</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116419.html" target="_blank" rel="external">策略模式</a>：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。例如：商场中的打折商品，针对不同的客户可能有不同的折扣。那这些算法该怎么定义呢？可以使用策略模式，给每个会员或者商品都指定一个特定的算法，根据不同的算法，打不同的折扣。</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116440.html" target="_blank" rel="external">职责链模式</a>：将能够处理同一类请求的对象连成一条链，使这些对象都有机会处理请求，所提交的请求沿着链传递。从而避免请求的发送者和接受者之间的耦合关系。链上的对象逐个判断是否有能力处理该请求，如果能则就处理，如果不能，则传给链上的下一个对象。直到有一个对象处理它为止。比如：请假申请，审批人连成一条链，每个人都有机会处理这个假条，但是这个请假申请最终肯定会经过审核（不管审批是否通过）。</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116422.html" target="_blank" rel="external">访问者模式</a>（不常用）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
</li>
</ul>
<h4 id="结构型模式：关注对象和类的组织"><a href="#结构型模式：关注对象和类的组织" class="headerlink" title="结构型模式：关注对象和类的组织"></a>结构型模式：关注对象和类的组织</h4><ul>
<li><p><a href="http://www.cnblogs.com/meet/p/5116467.html" target="_blank" rel="external">适配器模式</a>：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的类可以一起工作。例如：NBA中的球员来自不同国家，而世界标准语言是英语。那他们不会英语，也不能各自学习所有国家的语言。所以，最好的办法就是请不同的翻译,将这些球员国家的语言翻译成英语。而这些翻译就是适配器！！<br>适配器模式分类：<br>1、类适配器模式（不推荐使用）：由于类适配器模式需要多重继承对一个接口对另一个接口进行适配，而C#,Java不支持多重继承。<br>2、对象适配器模式：采用组合的方式</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116458.html" target="_blank" rel="external">桥接模式</a>：将抽象部分与它的实现部分分离，使它们都可以独立的变化。而不会直接影响到其他部分。桥接模式解决了多层继承的结构，处理多维度变化的场景，将各个维度设计成独立的继承结构。使各个维度可以独立的扩展在抽象层建立联系。</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116450.html" target="_blank" rel="external">装饰模式</a>：也叫装饰者模式或者装饰器模式，表示动态的给一个对象添加一些新的功能（利用子类继承父类也可以实现），但是比生成子类方式更灵活。例如：我们每个人身上穿的衣服，鞋子，领带，披风都可以理解为是对人的装饰。</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116455.html" target="_blank" rel="external">组合模式</a>：将对象组合成树形结构以表示：部分–整体 的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。基本上见到的树形结构都使用到了组合模式。</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116447.html" target="_blank" rel="external">外观模式</a>：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口。这个接口使得这一子系统更加容易使用。遵守迪米特法则（最少知识原则）。说白了，就可以理解为封装。外观模式的核心：为子系统提供统一的入口，封装子系统的复杂性，便于客户端调用</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116445.html" target="_blank" rel="external">享元模式</a>：运用共享技术有效的支持大量细粒度对象的重用。它能做到共享的关键就是区分了内部状态（可以共享，不会随环境变化而变化）和外部状态（不可以共享，会随环境变化而变化）。如果项目中有很多完全相同或相似的对象，则可以使用享元模式，节省内存。</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116464.html" target="_blank" rel="external">代理模式</a>：为其他对象提供一种代理以便控制对这个对象的访问。可以详细控制访问某个类（对象）的方法，在调用这个方法前作的前置处理（统一的流程代码放到代理中处理）。调用这个方法后做后置处理。例如：明星的经纪人，租房的中介等等都是代理<br>代理模式分类：<br>1.静态代理（静态定义代理类，我们自己静态定义的代理类。比如我们自己定义一个明星的经纪人类）<br>2.动态代理（通过程序动态生成代理类，该代理类不是我们自己定义的。而是由程序自动生成）比较重要！！</p>
</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><p>大话设计模式(带目录完整版).pdf</p>
</li>
<li><p>HEAD_FIRST设计模式（中文版）.pdf</p>
</li>
<li><p>尚学堂_高淇<em>java300集最全视频教程</em>【GOF23设计模式】</p>
</li>
<li><p><a href="http://www.cnblogs.com/meet/p/5116504.html" target="_blank" rel="external">FangZheng - 博客园</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##&lt;center&gt;java 23种设计模式概括&lt;/ceter&gt;&lt;/p&gt;
&lt;h3 id=&quot;目录概览&quot;&gt;&lt;a href=&quot;#目录概览&quot; class=&quot;headerlink&quot; title=&quot;目录概览&quot;&gt;&lt;/a&gt;目录概览&lt;/h3&gt;&lt;h4 id=&quot;创建型模式：关注对象的创建过程&quot;&gt;&lt;a href=&quot;#创建型模式：关注对象的创建过程&quot; class=&quot;headerlink&quot; title=&quot;创建型模式：关注对象的创建过程&quot;&gt;&lt;/a&gt;创建型模式：关注对象的创建过程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/meet/p/5116398.html&quot;&gt;单例模式&lt;/a&gt;：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点&lt;br&gt;主要：&lt;br&gt;饿汉式（线程安全，调用效率高，但是不能延时加载）&lt;br&gt;懒汉式（线程安全，调用效率不高，但是可以延时加载）&lt;br&gt;其他：&lt;br&gt;双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）&lt;br&gt;静态内部类式（线程安全，调用效率高。但是可以延时加载）&lt;br&gt;枚举单例（线程安全，调用效率高，不能延时加载）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/meet/p/5116400.html&quot;&gt;工厂模式&lt;/a&gt;：&lt;br&gt;简单工厂模式：用来生产同一等级结构中的任意产品（对已有产品新增功能，需要修改源代码）&lt;br&gt;虽然能通过工厂来创建对象，但是违反了开闭原则。一旦增加功能需要在原有基础上修改代码。&lt;br&gt;工厂方法模式：用来生产同一等级结构中的固定产品（支持增加任意产品，不用修改源代码）&lt;br&gt;将工厂类调整为工厂接口，需要什么类型的工厂就使用该类实现该工厂，创建相应的产品。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/meet/p/5116400.html&quot;&gt;抽象工厂模式&lt;/a&gt;：用来生产不同产品族的全部产品（对于增加新的产品，无能为力。可增加一系列的产品族）抽象工厂模式用来生产不同产品族的全部产品，对于只增加产品某一部分则不适用。抽象工厂模式是工厂模式的一种升级版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/meet/p/5116401.html&quot;&gt;建造者​模式&lt;/a&gt;：分离了对象子组件的单独构造（由Builder来负责构建，由Director来负责组装），从而可以构造出复杂的对象。&lt;br&gt;假如一个对象的构建很复杂，需要很多步骤。如果使用了建造者模式，会将其构建对象，和组装成一个对象这两步给分开来构建部分为（builder）和组织部分（director），实现了构建和装配的解耦。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://ymjava.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>并发包总结（二）</title>
    <link href="http://ymjava.cn/archives/3699126a.html"/>
    <id>http://ymjava.cn/archives/3699126a.html</id>
    <published>2018-02-23T09:03:02.000Z</published>
    <updated>2018-02-24T07:35:26.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-util-concurrent-包-java并发编程包（二）"><a href="#java-util-concurrent-包-java并发编程包（二）" class="headerlink" title="java.util.concurrent 包 java并发编程包（二）"></a><center>java.util.concurrent 包 java并发编程包（二）</center></h2><h3 id="阻塞队列（BlockingQueue）-系列用法"><a href="#阻塞队列（BlockingQueue）-系列用法" class="headerlink" title="阻塞队列（BlockingQueue）  系列用法"></a>阻塞队列（BlockingQueue）  系列用法</h3><p>BlockingQueue 通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。下图是对这个原理的阐述：<br><img src="http://img.blog.csdn.net/20150302184203260?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGVmb25kcw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="blockingQueue.png"></p>
<p>一个往线程里边放，另外一个线程从里边取的一个BlockingQueue。</p>
<p>一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。<br>负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。</p>
<h4 id="BlockingQueue-的方法"><a href="#BlockingQueue-的方法" class="headerlink" title="BlockingQueue 的方法"></a>BlockingQueue 的方法</h4><p> BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">抛异常</th>
<th style="text-align:center">特定值</th>
<th style="text-align:center">阻塞</th>
<th style="text-align:center">超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td style="text-align:center">add(o)</td>
<td style="text-align:center">offer(o)</td>
<td style="text-align:center">put(o)</td>
<td style="text-align:center">offer(o,timeout,timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td style="text-align:center">remove(o)</td>
<td style="text-align:center">poll(o)</td>
<td style="text-align:center">take(o)</td>
<td style="text-align:center">poll(o,timeout,timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td style="text-align:center">element(o)</td>
<td style="text-align:center">peek(o)</td>
</tr>
</tbody>
</table>
<p>四组不同的行为方式解释：</p>
<blockquote>
<p>1.抛异常：如果试图的操作无法立即执行，抛一个异常。<br>2.特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。<br>3.阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。<br>4.超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</p>
</blockquote>
<p>无法向一个 BlockingQueue 中插入 null。如果你试图插入 null，BlockingQueue 将会抛出一个 NullPointerException。可以访问到 BlockingQueue 中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o) 方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注：基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。<br><a id="more"></a></p>
<h4 id="BlockingQueue-的实现"><a href="#BlockingQueue-的实现" class="headerlink" title="BlockingQueue 的实现"></a>BlockingQueue 的实现</h4><p>BlockingQueue 是个接口，需要使用它的实现类之一来使用BlockingQueue.实现类有（this in java 6）:</p>
<ul>
<li><p>ArrayBlockingQueue</p>
</li>
<li><p>DelayQueue</p>
</li>
<li><p>LinkedBlockingQueue</p>
</li>
<li><p>PriorityBlockingQueue</p>
</li>
<li><p>SynchronousQueue</p>
</li>
</ul>
<h4 id="java中使用BlockingQueue-的例子"><a href="#java中使用BlockingQueue-的例子" class="headerlink" title="java中使用BlockingQueue 的例子"></a>java中使用BlockingQueue 的例子</h4><p>这里是一个 Java 中使用 BlockingQueue 的示例。本示例使用的是 BlockingQueue 接口的 ArrayBlockingQueue 实现。<br>首先，BlockingQueueExample 类分别在两个独立的线程中启动了一个 Producer 和 一个 Consumer。Producer 向一个共享的 BlockingQueue 中注入字符串，而 Consumer 则会从中把它们拿出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueExample</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">        BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1024</span>);</div><div class="line"></div><div class="line">        Producer producer = <span class="keyword">new</span> Producer(queue);</div><div class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(producer).start();</div><div class="line">        <span class="keyword">new</span> Thread(consumer).start();</div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">4000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是Producer 类。注意它在每次put()调用时是如何休眠一秒钟的。这将导致Consumer 在等待队列中对象的时候发生阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            queue.put(<span class="string">"1"</span>);</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            queue.put(<span class="string">"2"</span>);</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            queue.put(<span class="string">"3"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是 Consumer 类。它只是把对象从队列中抽取出来，然后将它们打印到 System.out。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(queue.take());</div><div class="line">            System.out.println(queue.take());</div><div class="line">            System.out.println(queue.take());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数组阻塞队列-ArrayBlockingQueue"><a href="#数组阻塞队列-ArrayBlockingQueue" class="headerlink" title="数组阻塞队列 ArrayBlockingQueue"></a>数组阻塞队列 ArrayBlockingQueue</h3><p>ArrayBlockingQueue 类实现了BlockingQueue 接口。<br>ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其进行初始化的时候设定这个上限，但之后就无法对这个上限进行修改了（ps:因为基于数组实现，具有数组的特性，一旦初始化，大小就无法修改）。<br>ArrayBlockingQueue 内部以FIFO（先进先出）的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾部元素是最短的那个。<br>以下是在使用  ArrayBlockingQueue 的时候对其初始化的一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1024</span>);</div><div class="line"></div><div class="line">queue.put(<span class="string">"1"</span>);</div><div class="line"></div><div class="line">Object object = queue.take();</div></pre></td></tr></table></figure>
<p>以下是使用了 Java 泛型的一个 BlockingQueue 示例。注意其中是如何对 String 元素放入和提取的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">1024</span>);</div><div class="line"></div><div class="line">queue.put(<span class="string">"1"</span>);</div><div class="line"></div><div class="line">String string = queue.take();</div></pre></td></tr></table></figure>
<h3 id="延迟队列-DelayQueue"><a href="#延迟队列-DelayQueue" class="headerlink" title="延迟队列 DelayQueue"></a>延迟队列 DelayQueue</h3><p>DelayQueue 实现了 BlockingQueue 接口。<br>DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口，该接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&lt; </span>&#123;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit timeUnit)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DelayQueue 将会在每个元素的 getDelay() 方法返回的值的时间段之后才释放掉该元素。如果返回的是 0 或者负值，延迟将被认为过期，该元素将会在 DelayQueue 的下一次 take  被调用的时候被释放掉。<br>传递给 getDelay 方法的 getDelay 实例是一个枚举类型，它表明了将要延迟的时间段。TimeUnit 枚举将会取以下值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DAYS</div><div class="line">HOURS</div><div class="line">MINUTES</div><div class="line">SECONDS</div><div class="line">MILLISECONDS</div><div class="line">MICROSECONDS</div><div class="line">NANOSECONDS</div></pre></td></tr></table></figure>
<p>正如你所看到的，Delayed 接口也继承了 java.lang.Comparable 接口，这也就意味着 Delayed 对象之间可以进行对比。这个可能在对 DelayQueue 队列中的元素进行排序时有用，因此它们可以根据过期时间进行有序释放。<br>以下是使用 DelayQueue 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueExample</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        DelayQueue queue = <span class="keyword">new</span> DelayQueue();</div><div class="line"></div><div class="line">        Delayed element1 = <span class="keyword">new</span> DelayedElement();</div><div class="line"></div><div class="line">        queue.put(element1);</div><div class="line"></div><div class="line">        Delayed element2 = queue.take();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DelayedElement 是我所创建的一个 DelayedElement 接口的实现类，它不在 java.util.concurrent 包里。你需要自行创建你自己的 Delayed 接口的实现以使用 DelayQueue 类。</p>
<h3 id="链阻塞队列LinkedBlockingQueue"><a href="#链阻塞队列LinkedBlockingQueue" class="headerlink" title="链阻塞队列LinkedBlockingQueue"></a>链阻塞队列LinkedBlockingQueue</h3><p>LinkedBlockingQueue 类实现了BlockingQueue接口。<br>LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。<br>LinkedBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。<br>以下是 LinkedBlockingQueue 的初始化和使用示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">BlockingQueue&lt;String&gt; unbounded = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</div><div class="line">BlockingQueue&lt;String&gt; bounded   = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(<span class="number">1024</span>);</div><div class="line"></div><div class="line">bounded.put(<span class="string">"Value"</span>);</div><div class="line"></div><div class="line">String value = bounded.take();</div></pre></td></tr></table></figure>
<h3 id="具有优先级的阻塞队列PriorityBlockingQueue"><a href="#具有优先级的阻塞队列PriorityBlockingQueue" class="headerlink" title="具有优先级的阻塞队列PriorityBlockingQueue"></a>具有优先级的阻塞队列PriorityBlockingQueue</h3><p>PriorityBlockingQueue 类实现了 BlockingQueue 接口。<br>PriorityBlockingQueue 是一个无界的并发队列。它使用了和类 java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。<br>所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。<br>注意 PriorityBlockingQueue 对于具有相等优先级(compare() == 0)的元素并不强制任何特定行为。<br>同时注意，如果你从一个 PriorityBlockingQueue 获得一个 Iterator 的话，该 Iterator 并不能保证它对元素的遍历是以优先级为序的。<br>以下是使用 PriorityBlockingQueue 的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">BlockingQueue queue   = <span class="keyword">new</span> PriorityBlockingQueue();</div><div class="line"></div><div class="line"><span class="comment">//String implements java.lang.Comparable</span></div><div class="line">queue.put(<span class="string">"Value"</span>);</div><div class="line"></div><div class="line">String value = queue.take();</div></pre></td></tr></table></figure>
<h3 id="同步队列SynchronousQueue"><a href="#同步队列SynchronousQueue" class="headerlink" title="同步队列SynchronousQueue"></a>同步队列SynchronousQueue</h3><p>SynchronousQueue 类实现了 BlockingQueue 接口。<br>SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。<br>据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。</p>
<h3 id="阻塞双端队列-BlockingDeque"><a href="#阻塞双端队列-BlockingDeque" class="headerlink" title="阻塞双端队列 BlockingDeque"></a>阻塞双端队列 BlockingDeque</h3><p>java.util.concurrent 包里的 BlockingDeque 接口表示一个线程安放入和提取实例的双端队列。本小节我将给你演示如何使用 BlockingDeque。<br>BlockingDeque 类是一个双端队列，在不能够插入元素时，它将阻塞住试图插入元素的线程；在不能够抽取元素时，它将阻塞住试图抽取的线程。<br>deque(双端队列) 是 “Double Ended Queue” 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。</p>
<p><img src="http://img.blog.csdn.net/20150303084557477?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGVmb25kcw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="BlockingDeque.png"></p>
<p>一个 BlockingDeque - 线程在双端队列的两端都可以插入和提取元素。<br>一个线程生产元素，并把它们插入到队列的任意一端。如果双端队列已满，插入线程将被阻塞，直到一个移除线程从该队列中移出了一个元素。如果双端队列为空，移除线程将被阻塞，直到一个插入线程向该队列插入了一个新元素。</p>
<p>BlockingDeque 的方法<br>BlockingDeque 具有 4 组不同的方法用于插入、移除以及对双端队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">抛异常</th>
<th style="text-align:center">特定值</th>
<th style="text-align:center">阻塞</th>
<th style="text-align:center">超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td style="text-align:center">addFirst(o)</td>
<td style="text-align:center">offerFirst(o)</td>
<td style="text-align:center">putFirst(o)</td>
<td style="text-align:center">offerFirst(o, timeout, timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td style="text-align:center">removeFirst(o)</td>
<td style="text-align:center">pollFirst(o)</td>
<td style="text-align:center">takeFirst(o)</td>
<td style="text-align:center">pollFirst(timeout, timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td style="text-align:center">getFirst(o)</td>
<td style="text-align:center">peekFirst(o)</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">抛异常</th>
<th style="text-align:center">特定值</th>
<th style="text-align:center">阻塞</th>
<th style="text-align:center">超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td style="text-align:center">addLast(o)</td>
<td style="text-align:center">offerLast(o)</td>
<td style="text-align:center">putLast(o)</td>
<td style="text-align:center">offerLast(o, timeout, timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td style="text-align:center">removeLast(o)</td>
<td style="text-align:center">pollLast(o)</td>
<td style="text-align:center">takeLast(o)</td>
<td style="text-align:center">pollLast(timeout, timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td style="text-align:center">getLast(o)</td>
<td style="text-align:center">peekLast(o)</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>四组不同的行为方式解释：</p>
<blockquote>
<p>1.抛异常：如果试图的操作无法立即执行，抛一个异常。<br>2.特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。<br>3.阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。<br>4.超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</p>
</blockquote>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://blog.csdn.net/defonds/article/details/44021605/" target="_blank" rel="external">Java 并发工具包 java.util.concurrent 用户指南</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java-util-concurrent-包-java并发编程包（二）&quot;&gt;&lt;a href=&quot;#java-util-concurrent-包-java并发编程包（二）&quot; class=&quot;headerlink&quot; title=&quot;java.util.concurrent 包 java并发编程包（二）&quot;&gt;&lt;/a&gt;&lt;center&gt;java.util.concurrent 包 java并发编程包（二）&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;阻塞队列（BlockingQueue）-系列用法&quot;&gt;&lt;a href=&quot;#阻塞队列（BlockingQueue）-系列用法&quot; class=&quot;headerlink&quot; title=&quot;阻塞队列（BlockingQueue）  系列用法&quot;&gt;&lt;/a&gt;阻塞队列（BlockingQueue）  系列用法&lt;/h3&gt;&lt;p&gt;BlockingQueue 通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。下图是对这个原理的阐述：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150302184203260?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGVmb25kcw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;blockingQueue.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;一个往线程里边放，另外一个线程从里边取的一个BlockingQueue。&lt;/p&gt;
&lt;p&gt;一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。&lt;br&gt;负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。&lt;/p&gt;
&lt;h4 id=&quot;BlockingQueue-的方法&quot;&gt;&lt;a href=&quot;#BlockingQueue-的方法&quot; class=&quot;headerlink&quot; title=&quot;BlockingQueue 的方法&quot;&gt;&lt;/a&gt;BlockingQueue 的方法&lt;/h4&gt;&lt;p&gt; BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;抛异常&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;特定值&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;阻塞&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;超时&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;插入&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;add(o)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offer(o)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;put(o)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offer(o,timeout,timeunit)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;移除&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;remove(o)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;poll(o)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;take(o)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;poll(o,timeout,timeunit)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;检查&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;element(o)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;peek(o)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;四组不同的行为方式解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.抛异常：如果试图的操作无法立即执行，抛一个异常。&lt;br&gt;2.特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。&lt;br&gt;3.阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。&lt;br&gt;4.超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无法向一个 BlockingQueue 中插入 null。如果你试图插入 null，BlockingQueue 将会抛出一个 NullPointerException。可以访问到 BlockingQueue 中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o) 方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注：基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://ymjava.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>concurrent并发包总结</title>
    <link href="http://ymjava.cn/archives/9880a961.html"/>
    <id>http://ymjava.cn/archives/9880a961.html</id>
    <published>2018-01-16T05:46:39.000Z</published>
    <updated>2018-02-24T07:35:26.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-util-concurrent-包-java并发编程包（一）"><a href="#java-util-concurrent-包-java并发编程包（一）" class="headerlink" title="java.util.concurrent 包 java并发编程包（一）"></a><center>java.util.concurrent 包 java并发编程包（一）</center></h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>通常所说的concurrent包基本有3个package组成<br>java.util.concurrent：提供大部分关于并发的接口和类，如BlockingQueue,Callable,ConcurrentHashMap,ExecutorService, Semaphore等<br>java.util.concurrent.atomic：提供所有原子操作的类， 如AtomicInteger, AtomicLong等；<br>java.util.concurrent.locks:提供锁相关的类, 如Lock, ReentrantLock, ReadWriteLock, Condition等； </p>
<p>concurrent包的优点：</p>
<blockquote>
<ol>
<li>首先，功能非常丰富，诸如线程池(ThreadPoolExecutor)，CountDownLatch等并发编程中需要的类已经有现成的实现，不需要自己去实现一套； 毕竟jdk1.4对多线程编程的主要支持几乎就只有Thread, Runnable,synchronized等</li>
<li>concurrent包里面的一些操作是基于硬件级别的CAS(compare and swap),就是在cpu级别提供了原子操作，简单的说就可以提供无阻塞、无锁定的算法； 而现代cpu大部分都是支持这样的算法的；</li>
</ol>
</blockquote>
<h3 id="闭锁CountDownLatch"><a href="#闭锁CountDownLatch" class="headerlink" title="闭锁CountDownLatch"></a>闭锁CountDownLatch</h3><p>java.util.concurrent.CountDownLatch 是一个并发构造，它允许一个或多个线程等待一系列指定操作的完成。</p>
<p>通常的使用场景是，某个主线程接到一个任务，起了n个子线程去完成，但是主线程需要等待这n个子线程都完成任务了以后才开始执行某个操作； </p>
<p>演示代码</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoCountDown</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</div><div class="line">    <span class="keyword">final</span> CountDownLatch l = <span class="keyword">new</span> CountDownLatch(count);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.currentThread().sleep(<span class="number">20</span> * <span class="number">1000</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"></div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                System.out.println(<span class="string">"thread "</span> + index + <span class="string">" has finished..."</span>);</div><div class="line"></div><div class="line">                l.countDown();</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        l.await();</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"now all threads have finished"</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有当前面10个线程执行完成，最后一句话才会执行打印。（ps：10个线程执行顺序不定）<br><!--more--></p>
<h3 id="Atomic类"><a href="#Atomic类" class="headerlink" title="Atomic类"></a>Atomic类</h3><p>Atomic相关的类，比如AtomicLong, AtomicInteger等这些；<br>简单的说，这些类都是线程安全的，支持无阻塞无锁定的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">set()</div><div class="line">get()</div><div class="line">getAndSet()</div><div class="line">getAndIncrement()</div><div class="line">getAndDecrement()</div><div class="line">getAndAdd()</div></pre></td></tr></table></figure>
<p>等操作</p>
<p>演示代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.hetaoblog.concurrent.test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * by http://www.hetaoblog.com</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> hetaoblog</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAtomic</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> loopcount = <span class="number">10000</span>;</div><div class="line">        <span class="keyword">int</span> threadcount = <span class="number">10</span>;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> NonSafeSeq seq1 = <span class="keyword">new</span> NonSafeSeq();</div><div class="line">        <span class="keyword">final</span> SafeSeq seq2 = <span class="keyword">new</span> SafeSeq();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> CountDownLatch l = <span class="keyword">new</span> CountDownLatch(threadcount);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadcount; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopcount; ++j) &#123;</div><div class="line"></div><div class="line">                        seq1.inc();</div><div class="line">                        seq2.inc();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    System.out.println(<span class="string">"finished : "</span> + index);</div><div class="line">                    l.countDown();</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            l.await();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"both have finished...."</span>);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"NonSafeSeq:"</span> + seq1.get());</div><div class="line">        System.out.println(<span class="string">"SafeSeq with atomic: "</span> + seq2.get());</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonSafeSeq</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeSeq</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> AtomicLong count = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</div><div class="line">        count.incrementAndGet();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count.longValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中NonSafeSeq是作为对比的类，直接放一个private long count不是线程安全的，而SafeSeq里面放了一个AtomicLong,是线程安全的；可以直接调用incrementAndGet来增加</p>
<p>运行代码，可以得到类似这样的结果<br>finished : 1<br>finished : 0<br>finished : 3<br>finished : 2<br>finished : 5<br>finished : 4<br>finished : 6<br>finished : 8<br>finished : 9<br>finished : 7<br>both have finished….<br>NonSafeSeq:91723<br>SafeSeq with atomic: 100000</p>
<p>可以看到，10个线程，每个线程运行了10,000次，理论上应该有100,000次增加，使用了普通的long是非线程安全的，而使用了AtomicLong是线程安全的；</p>
<p>注意，这个例子也说明，虽然long本身的单个设置是原子的，要么成功要么不成功，但是诸如count++这样的操作就不是线程安全的；因为这包括了读取和写入两步操作；</p>
<h3 id="可以代替synchronized关键字的ReentrantLock"><a href="#可以代替synchronized关键字的ReentrantLock" class="headerlink" title="可以代替synchronized关键字的ReentrantLock"></a>可以代替synchronized关键字的ReentrantLock</h3><p>在jdk 1.4时代，线程间的同步主要依赖于synchronized关键字，本质上该关键字是一个对象锁，可以加在不同的instance上或者class上，从使用的角度则分别可以加在非静态方法，静态方法，以及直接synchronized(MyObject)这样的用法；<br>concurrent包提供了一个可以替代synchronized关键字的ReentrantLock，<br>简单的说你可以new一个ReentrantLock， 然后通过lock.lock和lock.unlock来获取锁和释放锁；注意必须将unlock放在finally块里面，<br>reentrantlock的好处</p>
<ol>
<li>是更好的性能，</li>
<li>提供同一个lock对象上不同condition的信号通知</li>
<li>还提供lockInterruptibly这样支持响应中断的加锁过程，意思是说你试图去加锁，但是当前锁被其他线程hold住，然后你这个线程可以被中断；</li>
</ol>
<p>演示代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.hetaoblog.concurrent.test;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoLock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> loopcount = <span class="number">10000</span>;</div><div class="line">        <span class="keyword">int</span> threadcount = <span class="number">10</span>;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> SafeSeqWithLock seq = <span class="keyword">new</span> SafeSeqWithLock();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> CountDownLatch l = <span class="keyword">new</span> CountDownLatch(threadcount);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadcount; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopcount; ++j) &#123;</div><div class="line"></div><div class="line">                        seq.inc();</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    System.out.println(<span class="string">"finished : "</span> + index);</div><div class="line">                    l.countDown();</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            l.await();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"both have finished...."</span>);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"SafeSeqWithLock:"</span> + seq.get());</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeSeqWithLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</div><div class="line">        lock.lock();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            count++;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样以前面的类似Sequence的类举例，通过对inc操作加锁，保证了线程安全；<br>当然，这里get()我没有加锁，对于这样直接读取返回原子类型的函数，我认为不加锁是没问题的，相当于返回最近成功操作的值； </p>
<p>运行结果类似这样，<br>finished : 7<br>finished : 2<br>finished : 6<br>finished : 1<br>finished : 5<br>finished : 3<br>finished : 0<br>finished : 9<br>finished : 8<br>finished : 4<br>both have finished….<br>SafeSeqWithLock:100000</p>
<h3 id="读写锁ReadWriteLock"><a href="#读写锁ReadWriteLock" class="headerlink" title="读写锁ReadWriteLock"></a>读写锁ReadWriteLock</h3><p>concurrent包里面还提供了一个非常有用的锁，读写锁ReadWriteLock<br>下面是ReadWriteLock接口的说明：<br>A ReadWriteLock maintains a pair of associated locks, one for read-only operations and one for writing. The read lock may be held simultaneously by multiple reader threads, so long as there are no writers. The write lock is exclusive. </p>
<p>意思是说读锁可以有很多个锁同时上锁，只要当前没有写锁；<br>写锁是排他的，上了写锁，其他线程既不能上读锁，也不能上写锁；同样，需要上写锁的前提是既没有读锁，也没有写锁；<br>两个写锁不能同时获得无需说明，下面一段程序说明下上了读锁以后，其他线程需要上写锁也无法获得</p>
<p>演示代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span>  LN</div><div class="line"> * <span class="doctag">@create</span> 2018-02-10 15:02</div><div class="line"> **/</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">concurrentTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRWLock_getw_onr</span><span class="params">()</span></span>&#123;</div><div class="line">        ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Lock rlock = lock.readLock();</div><div class="line">        <span class="keyword">final</span> Lock wlock = lock.writeLock();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> CountDownLatch l = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</div><div class="line"></div><div class="line">        <span class="comment">//start r thread</span></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">"now to get rlock"</span>);</div><div class="line">                rlock.lock();</div><div class="line"></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.currentThread().sleep(<span class="number">20</span>*<span class="number">1000</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ev) &#123;</div><div class="line">                    ev.printStackTrace();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">"now to unlock rlock"</span>);</div><div class="line">                rlock.unlock();</div><div class="line"></div><div class="line">                l.countDown();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">        <span class="comment">//start w lock</span></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">"now to get wlock"</span>);</div><div class="line">                wlock.lock();</div><div class="line"></div><div class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">"now to unlock wlock"</span>);</div><div class="line">                wlock.unlock();</div><div class="line"></div><div class="line">                l.countDown();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            l.await();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="keyword">new</span> Date() + <span class="string">"now to finished"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在试图获取写锁时，写锁线程必须等读锁线程将读锁释放了之后才可以获得写锁。</p>
<p>结果：<br>Sat Feb 10 15:26:09 CST 2018now to get rlock<br>Sat Feb 10 15:26:09 CST 2018now to get wlock<br>Sat Feb 10 15:26:29 CST 2018now to unlock rlock<br>Sat Feb 10 15:26:29 CST 2018now to unlock wlock<br>Sat Feb 10 15:26:29 CST 2018now to finished</p>
<p>ReadWriteLock的实现是ReentrantReadWriteLock，<br>有趣的是，在一个线程中，读锁不能直接升级为写锁，但是写锁可以降级为读锁；<br>这意思是，如果你已经有了读锁，再去试图获得写锁，将会无法获得， 一直堵住了；<br>但是如果你有了写锁，再去试图获得读锁，没问题；</p>
<p>下面是一段降级的代码，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testRWLock_downgrade()</div><div class="line">&#123;</div><div class="line">    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();</div><div class="line"></div><div class="line">    Lock rlock = lock.readLock();</div><div class="line">    Lock wlock = lock.writeLock();</div><div class="line"></div><div class="line">    System.out.println("now to get wloc</div><div class="line">    k");</div><div class="line">    wlock.lock();</div><div class="line">    System.out.println("now to get rlock");</div><div class="line">    rlock.lock();</div><div class="line"></div><div class="line">    System.out.println("now to unlock wlock");</div><div class="line"></div><div class="line">    wlock.unlock();</div><div class="line"></div><div class="line">    System.out.println("now to unlock rlock");</div><div class="line">    rlock.unlock();</div><div class="line"></div><div class="line">    System.out.println("finished");</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p><a href="http://www.iteye.com/topic/1121021" target="_blank" rel="external">说一说java的concurrent包-系列文章</a></p>
</li>
<li><p><a href="http://blog.csdn.net/defonds/article/details/44021605/" target="_blank" rel="external">Java 并发工具包 java.util.concurrent 用户指南</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java-util-concurrent-包-java并发编程包（一）&quot;&gt;&lt;a href=&quot;#java-util-concurrent-包-java并发编程包（一）&quot; class=&quot;headerlink&quot; title=&quot;java.util.concurrent 包 java并发编程包（一）&quot;&gt;&lt;/a&gt;&lt;center&gt;java.util.concurrent 包 java并发编程包（一）&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h3&gt;&lt;p&gt;通常所说的concurrent包基本有3个package组成&lt;br&gt;java.util.concurrent：提供大部分关于并发的接口和类，如BlockingQueue,Callable,ConcurrentHashMap,ExecutorService, Semaphore等&lt;br&gt;java.util.concurrent.atomic：提供所有原子操作的类， 如AtomicInteger, AtomicLong等；&lt;br&gt;java.util.concurrent.locks:提供锁相关的类, 如Lock, ReentrantLock, ReadWriteLock, Condition等； &lt;/p&gt;
&lt;p&gt;concurrent包的优点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;首先，功能非常丰富，诸如线程池(ThreadPoolExecutor)，CountDownLatch等并发编程中需要的类已经有现成的实现，不需要自己去实现一套； 毕竟jdk1.4对多线程编程的主要支持几乎就只有Thread, Runnable,synchronized等&lt;/li&gt;
&lt;li&gt;concurrent包里面的一些操作是基于硬件级别的CAS(compare and swap),就是在cpu级别提供了原子操作，简单的说就可以提供无阻塞、无锁定的算法； 而现代cpu大部分都是支持这样的算法的；&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;闭锁CountDownLatch&quot;&gt;&lt;a href=&quot;#闭锁CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;闭锁CountDownLatch&quot;&gt;&lt;/a&gt;闭锁CountDownLatch&lt;/h3&gt;&lt;p&gt;java.util.concurrent.CountDownLatch 是一个并发构造，它允许一个或多个线程等待一系列指定操作的完成。&lt;/p&gt;
&lt;p&gt;通常的使用场景是，某个主线程接到一个任务，起了n个子线程去完成，但是主线程需要等待这n个子线程都完成任务了以后才开始执行某个操作； &lt;/p&gt;
&lt;p&gt;演示代码&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://ymjava.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker 初识</title>
    <link href="http://ymjava.cn/archives/fd0b65d2.html"/>
    <id>http://ymjava.cn/archives/fd0b65d2.html</id>
    <published>2017-11-27T06:50:54.000Z</published>
    <updated>2017-12-10T05:28:27.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-初识"><a href="#Docker-初识" class="headerlink" title="Docker 初识"></a>Docker 初识</h1><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><a href="#相关文档">相关文档</a></p>
<p><a href="#简介">简介</a></p>
<p><a href="#概念">概念</a></p>
<p><a href="#基础环境搭建">Docekr 基础环境搭建</a></p>
<p><a href="#运用场景">Docker 运用场景</a></p>
<h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a><a id="相关文档"></a>相关文档</h3><ul>
<li><a href="https://yq.aliyun.com/articles/63035?utm_campaign=wenzhang&amp;utm_medium=article&amp;utm_source=QQ-qun&amp;utm_content=m_7538" target="_blank" rel="external">大白话Docker入门（一）</a></li>
<li><a href="http://www.linuxidc.com/Linux/2014-10/107969.htm" target="_blank" rel="external">利用Docker构建开发环境详解</a></li>
<li><a href="http://blog.csdn.net/21cnbao/article/details/56275456" target="_blank" rel="external">宋宝华：Docker 最初的2小时(Docker从入门到入门)</a></li>
<li><a href="https://aotu.io/notes/2016/02/27/docker/index.html" target="_blank" rel="external">初探Docker</a></li>
<li><a href="https://www.cnblogs.com/liusc/p/docker_node.html" target="_blank" rel="external">Docker实战–部署简单nodejs应用</a></li>
<li><a href="https://yq.aliyun.com/articles/29941" target="_blank" rel="external">Docker 镜像加速器</a></li>
</ul>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><a id="简介"></a>简介</h3><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><a id="概念"></a>概念</h3><p>KVM, Virtualbox, Vmware是虚拟出机器，让每个实例看到一个单独的机器；而Docker是虚拟出操作系统，实现应用之间的隔离，让各个应用觉得自己有一个自己的操作系统，而且彼此之间隔离。</p>
<p>Docker由下面几样东西组成：</p>
<ul>
<li>Docker Client : Docker提供给用户的客户端。Docker Client提供给用户一个终端，用户输入Docker提供的命令来管理本地或者远程的服务器。</li>
<li>Docker Daemon : Docker服务的守护进程。每台服务器（物理机或虚机）上只要安装了Docker的环境，基本上就跑了一个后台程序Docker Daemon，Docker Daemon会接收Docker Client发过来的指令,并对服务器的进行具体操作。</li>
<li>Docker Images : 俗称Docker的镜像，这个可难懂了。你暂时可以认为这个就像我们要给电脑装系统用的系统CD盘，里面有操作系统的程序，并且还有一些CD盘在系统的基础上安装了必要的软件，做成的一张 “只读” 的CD。</li>
<li>Docker Registry : 这个可认为是Docker Images的仓库，就像git的仓库一样，用来管理Docker镜像的，提供了Docker镜像的上传、下载和浏览等功能，并且提供安全的账号管理可以管理只有自己可见的私人image。就像git的仓库一样，docker也提供了官方的Registry，叫做<a href="http://hub.Docker.com" target="_blank" rel="external">Dock Hub</a></li>
<li>Docker Container : 俗称Docker的容器，这个是最关键的东西了。Docker Container是真正跑项目程序、消耗机器资源、提供服务的地方，Docker Container通过Docker Images启动，在Docker Images的基础上运行你需要的代码。 你可以认为Docker Container提供了系统硬件环境，然后使用了Docker Images这些制作好的系统盘，再加上你的项目代码，跑起来就可以提供服务了。</li>
</ul>
<p><img src="http://oyz8j0ezy.bkt.clouddn.com/docker_build.png" alt=""></p>
<a id="more"></a>
<p>Docker Container 的示例图：</p>
<p><img src="http://oyz8j0ezy.bkt.clouddn.com/docker_container.png" alt=""></p>
<p>Container和Image 在Docker的世界里，Image是指一个只读的层（Layer），这里的层是AUFS里的概念，最直观的方式就是看一下docker官方给出的图：</p>
<p><img src="http://oyz8j0ezy.bkt.clouddn.com/dockercontainerandimage.png" alt=""></p>
<p>Docker使用了一种叫AUFS的文件系统，这种文件系统可以让你一层一层地叠加修改你的文件，最底下的文件系统是只读的，如果需要修改文件，AUFS会增加一个可写的层（Layer），这样有很多好处，例如不同的Container可以共享底层的只读文件系统（同一个Kernel），使得你可以跑N多个Container而不至于你的硬盘被挤爆了！这个只读的层就是Image！而如你所看到的，一个可写的层就是Container。</p>
<h3 id="Docker-基础环境搭建（阿里云仓库创建、提交）"><a href="#Docker-基础环境搭建（阿里云仓库创建、提交）" class="headerlink" title="Docker 基础环境搭建（阿里云仓库创建、提交）"></a><a id="基础环境搭建"></a>Docker 基础环境搭建（阿里云仓库创建、提交）</h3><ul>
<li><p>首先安装基于你的系统的Docker环境，建议参考<a href="http://www.docker.com/products/docker" target="_blank" rel="external">docker</a>的官网以及相关问题百度。<br>（注：如果是win10专业版，因为自带了虚拟机Hyper-V,所以可以下载专门匹配的docker for windows 10，其他的window版本，建议下载Docker Toolbox，它包含了运行Docker时需要的一切：Docker客户端、Compose（仅Mac需要）、Kitematic、Machine以及VirtualBox。）</p>
</li>
<li><p>安装完成后一般双击你桌面的快捷图标（Docker Quickstart Terminal），它会初始化去github下载一个虚拟机的默认的default镜像文件，一般这个下载非常慢，建议直接访问<a href="https://github.com/boot2docker/boot2docker/releases" target="_blank" rel="external">https://github.com/boot2docker/boot2docker/releases</a> 下载对应版本的boot2docker.iso<br>然后复制粘贴到C:\Users\LN.docker\machine\cache目录下，这样可以完成docker的首次启动。<br>查看 docker version </p>
</li>
</ul>
<p><img src="http://oyz8j0ezy.bkt.clouddn.com/dockerversion.png" alt=""></p>
<p>我们也可以查看相关的一些命令，查看镜像 docker images、查看容器 docker ps -a 、查看正在运行的容器 docker ps 等。</p>
<ul>
<li><p>因为docker默认的官方仓库是<a href="https://hub.docker.com" target="_blank" rel="external">https://hub.docker.com</a> , 访问困难，所以我们在拉取镜像的时候一般选择国内的docker仓库，如网易，阿里都有对应的docker镜像仓库。我们拿<a href="https://dev.aliyun.com/search.html" target="_blank" rel="external">阿里</a>的仓库镜像做介绍。使用docker info  查看我们是否配备好了国内加速器。</p>
</li>
<li><p>拉取镜像 docker pull centos ，使用阿里云加速。使用命令  sudo docker run -it ubuntu:14.04 /bin/bash ， 运行之后我们就有了一个Ubuntu的基础环境，我们可以把拉取下来的镜像 添加gcc和vim ，添加构建文件Dockerfile</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir myubuntuWithVimAndGcc</div><div class="line"><span class="built_in">cd</span> myubuntuWithVimAndGcc &amp;&amp; touch Dockerfile</div><div class="line">vi Dockerfile</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Ubuntu 14.04 with vim and gcc</span></div><div class="line">FROM ubuntu:14.04</div><div class="line">MAINTAINER Barry Song&lt;ningfan210@163.com</div><div class="line">RUN apt-get update &amp;&amp; apt-get install -y vim gcc</div></pre></td></tr></table></figure>
<p>然后通过命令 sudo docker build -t ubuntu/ubuntuwithvimandgcc . ，试着运行一下,<br>测试下gcc 和 vim ,发现已经装好了，<br><img src="http://oyz8j0ezy.bkt.clouddn.com/ubuntuwithgcc.png" alt=""></p>
<ul>
<li>最后我们可以发布我们的镜像到阿里的自己的仓库中，可以让别人拉取。</li>
</ul>
<h3 id="Docker-运用场景-（Docker-搭建基础项目环境）"><a href="#Docker-运用场景-（Docker-搭建基础项目环境）" class="headerlink" title="Docker 运用场景 （Docker 搭建基础项目环境）"></a><a id="运用场景"></a>Docker 运用场景 （Docker 搭建基础项目环境）</h3><ul>
<li>作为示范，我们演示下，在docker环境中搭建一个运行在nodejs环境下的hexo博客。<br>首先编写构建文件Dockerfile：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">FROM node</div><div class="line">MAINTAINER NANMEN</div><div class="line"></div><div class="line">RUN npm install -g hexo --registry=https://registry.npm.taobao.org</div><div class="line"></div><div class="line">RUN mkdir -p hexofile</div><div class="line"></div><div class="line">WORKDIR /hexofile</div><div class="line"></div><div class="line">RUN hexo init</div><div class="line"></div><div class="line">RUN hexo generate</div><div class="line"></div><div class="line">EXPOSE 4000</div><div class="line"></div><div class="line">CMD [<span class="string">"hexo"</span>,<span class="string">"server"</span>]</div><div class="line">~</div></pre></td></tr></table></figure>
<p>然后使用命令 sudo docker build -t hexo/node . 命令构建我们的hexo的镜像，因为hexo运行时是跑在端口4000上，所以我们在执行运行命令的时候需要运用到 -p 命令做端口映射，如<br>sudo docker run -d -p 4000:4000 hexo/node:latest ,然后在浏览器中访问 <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> </p>
<p><img src="http://oyz8j0ezy.bkt.clouddn.com/dockerandhexo.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-初识&quot;&gt;&lt;a href=&quot;#Docker-初识&quot; class=&quot;headerlink&quot; title=&quot;Docker 初识&quot;&gt;&lt;/a&gt;Docker 初识&lt;/h1&gt;&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;#相关文档&quot;&gt;相关文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#简介&quot;&gt;简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#概念&quot;&gt;概念&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#基础环境搭建&quot;&gt;Docekr 基础环境搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#运用场景&quot;&gt;Docker 运用场景&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;相关文档&quot;&gt;&lt;a href=&quot;#相关文档&quot; class=&quot;headerlink&quot; title=&quot;相关文档&quot;&gt;&lt;/a&gt;&lt;a id=&quot;相关文档&quot;&gt;&lt;/a&gt;相关文档&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/63035?utm_campaign=wenzhang&amp;amp;utm_medium=article&amp;amp;utm_source=QQ-qun&amp;amp;utm_content=m_7538&quot;&gt;大白话Docker入门（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.linuxidc.com/Linux/2014-10/107969.htm&quot;&gt;利用Docker构建开发环境详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/21cnbao/article/details/56275456&quot;&gt;宋宝华：Docker 最初的2小时(Docker从入门到入门)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aotu.io/notes/2016/02/27/docker/index.html&quot;&gt;初探Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/liusc/p/docker_node.html&quot;&gt;Docker实战–部署简单nodejs应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/29941&quot;&gt;Docker 镜像加速器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;a id=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。&lt;/p&gt;
&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;&lt;a id=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;KVM, Virtualbox, Vmware是虚拟出机器，让每个实例看到一个单独的机器；而Docker是虚拟出操作系统，实现应用之间的隔离，让各个应用觉得自己有一个自己的操作系统，而且彼此之间隔离。&lt;/p&gt;
&lt;p&gt;Docker由下面几样东西组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker Client : Docker提供给用户的客户端。Docker Client提供给用户一个终端，用户输入Docker提供的命令来管理本地或者远程的服务器。&lt;/li&gt;
&lt;li&gt;Docker Daemon : Docker服务的守护进程。每台服务器（物理机或虚机）上只要安装了Docker的环境，基本上就跑了一个后台程序Docker Daemon，Docker Daemon会接收Docker Client发过来的指令,并对服务器的进行具体操作。&lt;/li&gt;
&lt;li&gt;Docker Images : 俗称Docker的镜像，这个可难懂了。你暂时可以认为这个就像我们要给电脑装系统用的系统CD盘，里面有操作系统的程序，并且还有一些CD盘在系统的基础上安装了必要的软件，做成的一张 “只读” 的CD。&lt;/li&gt;
&lt;li&gt;Docker Registry : 这个可认为是Docker Images的仓库，就像git的仓库一样，用来管理Docker镜像的，提供了Docker镜像的上传、下载和浏览等功能，并且提供安全的账号管理可以管理只有自己可见的私人image。就像git的仓库一样，docker也提供了官方的Registry，叫做&lt;a href=&quot;http://hub.Docker.com&quot;&gt;Dock Hub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker Container : 俗称Docker的容器，这个是最关键的东西了。Docker Container是真正跑项目程序、消耗机器资源、提供服务的地方，Docker Container通过Docker Images启动，在Docker Images的基础上运行你需要的代码。 你可以认为Docker Container提供了系统硬件环境，然后使用了Docker Images这些制作好的系统盘，再加上你的项目代码，跑起来就可以提供服务了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://oyz8j0ezy.bkt.clouddn.com/docker_build.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://ymjava.cn/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>IM即时通讯资料整理</title>
    <link href="http://ymjava.cn/archives/a5d8a8b7.html"/>
    <id>http://ymjava.cn/archives/a5d8a8b7.html</id>
    <published>2017-11-13T03:00:10.000Z</published>
    <updated>2017-11-21T07:54:15.079Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="随笔" scheme="http://ymjava.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="IM即时通讯" scheme="http://ymjava.cn/tags/IM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>即时通讯开源软件归纳</title>
    <link href="http://ymjava.cn/archives/b971456b.html"/>
    <id>http://ymjava.cn/archives/b971456b.html</id>
    <published>2017-11-10T01:11:45.000Z</published>
    <updated>2017-12-10T05:28:00.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="即时通讯开源软件归纳"><a href="#即时通讯开源软件归纳" class="headerlink" title="即时通讯开源软件归纳"></a><center>即时通讯开源软件归纳</center></h2><h3 id="开源归纳"><a href="#开源归纳" class="headerlink" title="开源归纳"></a>开源归纳</h3><p>因为需要兼容android和ios，所以一翻查找，暂时发现以下待定开源项目：</p>
<ul>
<li><p>基于<strong>XMPP</strong>  进行的二次开发项目，目前有基于服务端的开源项目：Openfire 。</p>
</li>
<li><p>基于<strong>MQTT</strong> 进行的二次开发项目。</p>
</li>
<li><p>基于<strong>MobileIMSDK</strong> 的二次开发项目。</p>
</li>
<li><p>基于<strong>T-IO</strong> 的二次开发项目。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="优良归纳"><a href="#优良归纳" class="headerlink" title="优良归纳"></a>优良归纳</h3><p>XMPP：是基于XML的,有服务器的开源项目ejabberd；</p>
<blockquote>
<p>ejabberd是基于Jabber/XMPP协议的即时通讯服务器，由GPLv2授权（免费和开放源码），采用Erlang/OTP开发。它的特点是，跨平台，容错，集群和模块化。<br>Ejabberd目前是可扩展性最好的一种Jabber/XMPP服务器，支持分布多个服务器，并且具有容错处理，单台服务器失效不影响整个cluster运作。</p>
</blockquote>
<p>完整的XMPP IM 实现（Openfire + Spark + Smack）：</p>
<blockquote>
<p>包括服务器端——Openfire，客户端——Spark，XMPP 传输协议的实现——Smack（记住，XMPP是一个协议，协议是需要实现的，Smack起到的就是这样的一个作用）。三者都是基于Java 语言的实现。</p>
</blockquote>
<p>缺点：其中XMPP是基于XML的,并且不支持消息质量QOS, 所以本身并没有消息重传的机制,从而会导致丢消息。</p>
<p>MQTT：是基于二进制的,支持QOS,并且已成为物联网的协议标准。</p>
<p>MobileIMSDK：是一个比较成熟的兼容android、IOS、java标准平台的一个开源项目。有比较成熟的基于其上的开发的demo和示例。</p>
<p>T-IO：有一个完善比较全面的开源项目，但是文档和示例比较少，估计需要自己爬不少的坑（慎选）。</p>
<hr>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><p><a href="http://blog.csdn.net/wbw1985/article/details/5502272" target="_blank" rel="external">XMPP协议的原理介绍</a></p>
</li>
<li><p><a href="https://my.oschina.net/yuanxulong/blog/348572" target="_blank" rel="external">基于openfire+smack的Android、Web、PC开发</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/findumars/p/6411060.html" target="_blank" rel="external">iOS和Android使用MQTT协议实现消息推送和即时通讯（替代XMPP，已经有TMS MQTT）</a></p>
</li>
<li><p><a href="http://blog.csdn.net/lv_ws/article/details/50295265" target="_blank" rel="external">Android mqtt即时通讯方案</a></p>
</li>
<li><p><a href="https://github.com/JackJiang2011/MobileIMSDK" target="_blank" rel="external">一个专为移动端开发的原创即时通讯框架，超轻量级、高度提炼，完全基于UDP协议，支持iOS、Android、标准Java平台。</a></p>
</li>
<li><p><a href="https://github.com/ChenYilong/iOSBlog/blob/master/Tips/%E5%9F%BA%E4%BA%8EWebsocket%E7%9A%84IM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E6%8A%80%E6%9C%AF/IM%20%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E6%8A%80%E6%9C%AF%E5%9C%A8%E5%A4%9A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%88iOS%E8%A7%86%E8%A7%92%EF%BC%89.md#%E5%9F%BA%E4%BA%8E-websocket-%E7%9A%84-im-%E7%B3%BB%E7%BB%9F" target="_blank" rel="external">基于Websocket的IM即时通讯技术/IM 即时通讯技术在多应用场景下的技术实现，以及性能调优（iOS视角）.md</a></p>
</li>
<li><p><a href="https://github.com/fanux/lhttp/blob/master/doc/README_zh.md" target="_blank" rel="external">Lhttp个基于websocket服务端框架</a></p>
</li>
<li><p><a href="http://t-io.org/#/" target="_blank" rel="external">t-io: 不仅仅是百万级即时通讯框架</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;即时通讯开源软件归纳&quot;&gt;&lt;a href=&quot;#即时通讯开源软件归纳&quot; class=&quot;headerlink&quot; title=&quot;即时通讯开源软件归纳&quot;&gt;&lt;/a&gt;&lt;center&gt;即时通讯开源软件归纳&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;开源归纳&quot;&gt;&lt;a href=&quot;#开源归纳&quot; class=&quot;headerlink&quot; title=&quot;开源归纳&quot;&gt;&lt;/a&gt;开源归纳&lt;/h3&gt;&lt;p&gt;因为需要兼容android和ios，所以一翻查找，暂时发现以下待定开源项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基于&lt;strong&gt;XMPP&lt;/strong&gt;  进行的二次开发项目，目前有基于服务端的开源项目：Openfire 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于&lt;strong&gt;MQTT&lt;/strong&gt; 进行的二次开发项目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于&lt;strong&gt;MobileIMSDK&lt;/strong&gt; 的二次开发项目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于&lt;strong&gt;T-IO&lt;/strong&gt; 的二次开发项目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://ymjava.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="IM即时通讯" scheme="http://ymjava.cn/tags/IM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"/>
    
      <category term="开源项目" scheme="http://ymjava.cn/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>记推送失败——git命令之ssh-add学习</title>
    <link href="http://ymjava.cn/archives/e8996bd7.html"/>
    <id>http://ymjava.cn/archives/e8996bd7.html</id>
    <published>2017-11-09T02:51:05.000Z</published>
    <updated>2017-11-09T07:11:11.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推送失败——git命令学习"><a href="#推送失败——git命令学习" class="headerlink" title="推送失败——git命令学习"></a><center>推送失败——git命令学习</center></h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>昨天更新文档推送设计模式的笔记，在git bash 命令框下输入以前的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g <span class="_">-d</span></div></pre></td></tr></table></figure>
<p>却给我报了个错误,<strong>Could not open a connection to your authentication agent</strong>，一翻百度发现解决方法如下：<br><a id="more"></a></p>
<blockquote>
<p>1.exec ssh-agent bash<br>2.eval ssh-agent -s<br>3.ssh-add “C:\Users\LN.ssh\id_rsa”</p>
</blockquote>
<p>将相应的秘钥地址改为你自己的地址，然后就可以愉快的输入测试命令了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div><div class="line">ssh -T git@git.coding.net</div></pre></td></tr></table></figure>
<p>测试通过，ok，然后就可以输入部署命令了。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="http://www.jianshu.com/p/1adbd697b249" target="_blank" rel="external">win下给 Git Bash 添加私钥时ssh-add报错的解决办法</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;推送失败——git命令学习&quot;&gt;&lt;a href=&quot;#推送失败——git命令学习&quot; class=&quot;headerlink&quot; title=&quot;推送失败——git命令学习&quot;&gt;&lt;/a&gt;&lt;center&gt;推送失败——git命令学习&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;昨天更新文档推送设计模式的笔记，在git bash 命令框下输入以前的&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;hexo g &lt;span class=&quot;_&quot;&gt;-d&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;却给我报了个错误,&lt;strong&gt;Could not open a connection to your authentication agent&lt;/strong&gt;，一翻百度发现解决方法如下：&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://ymjava.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>大话设计模式——读后感（2）</title>
    <link href="http://ymjava.cn/archives/d1e9f0a5.html"/>
    <id>http://ymjava.cn/archives/d1e9f0a5.html</id>
    <published>2017-11-06T07:51:42.000Z</published>
    <updated>2017-11-09T06:58:06.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大话设计模式——读后感（2）"><a href="#大话设计模式——读后感（2）" class="headerlink" title="大话设计模式——读后感（2）"></a><center>大话设计模式——读后感（2）</center></h2><h3 id="Tip2"><a href="#Tip2" class="headerlink" title="Tip2"></a>Tip2</h3><h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><blockquote>
<p>备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>
</blockquote>
<p><img src="http://images2015.cnblogs.com/blog/527668/201601/527668-20160109144237450-356010664.jpg" alt=""></p>
<p>Originator（发起人）：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。</p>
<p>Originator可根据需要决定Memento存储Originator的哪些内部状态</p>
<p>Memento（备忘录）：负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。</p>
<p>备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到</p>
<p>先前状态所需的所有数据。</p>
<p>Caretaker（管理者）：负责保存好备忘录Memento，不能对备忘录的内存进行操作或检查。<br><a id="more"></a></p>
<h4 id="备忘录模式代码实现"><a href="#备忘录模式代码实现" class="headerlink" title="备忘录模式代码实现"></a>备忘录模式代码实现</h4><p>以一个Emp实体对象来作为例子</p>
<p>首先，创建一个发起人：发起人内部保存着需要备忘的属性，它负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//发起人：发起人内部有自身的内部状态，并且发起人可以创建备忘录和恢复备忘录</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpOriginator</span> </span>&#123;</div><div class="line">    <span class="comment">//需要备份的自身属性</span></div><div class="line">    <span class="keyword">private</span> String ename;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</div><div class="line">    <span class="comment">//备份</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EmpMemento <span class="title">memento</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmpMemento(<span class="keyword">this</span>);<span class="comment">//将当前自身对象备份</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//恢复</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recovery</span><span class="params">(EmpMemento emp)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.ename = emp.getEname();</div><div class="line">        <span class="keyword">this</span>.age = emp.getAge();</div><div class="line">        <span class="keyword">this</span>.salary = emp.getSalary();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//省略get，set和带参构造器</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建备忘录对象：<font color="red">备忘录就是用来备份发起人的数据，所以构造器需要提供一个发起人对象</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//备忘录对象</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpMemento</span> </span>&#123;</div><div class="line">    <span class="comment">//自身属性</span></div><div class="line">    <span class="keyword">private</span> String ename;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary; </div><div class="line">    <span class="comment">//构造备忘录对象时，需要传入一个需要备忘的对象（发起人）</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmpMemento</span><span class="params">(EmpOriginator emp)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.ename = emp.getEname();</div><div class="line">        <span class="keyword">this</span>.age = emp.getAge();</div><div class="line">        <span class="keyword">this</span>.salary = emp.getSalary();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//省略3个属性的set,get方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开始创建一个备忘录的管理者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//管理者：管理备忘录对象</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</div><div class="line">    <span class="comment">//需要管理的备忘录对象，这里也可以使用一个list容器来存储。这样可以备份多个点  </span></div><div class="line">    <span class="keyword">private</span> EmpMemento empMemento;</div><div class="line">    <span class="function"><span class="keyword">public</span> EmpMemento <span class="title">getEmpMemento</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> empMemento;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmpMemento</span><span class="params">(EmpMemento empMemento)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.empMemento = empMemento;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单次备份测试：测试只能备份一次的备忘录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    CareTaker taker = <span class="keyword">new</span> CareTaker();<span class="comment">//构建一个备忘录管理者</span></div><div class="line">    <span class="comment">//构建发起人</span></div><div class="line">    EmpOriginator emp = <span class="keyword">new</span> EmpOriginator(<span class="string">"张三"</span>, <span class="number">20</span>, <span class="number">4000</span>);</div><div class="line">    System.out.println(<span class="string">"第一次："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line">    <span class="comment">//备份</span></div><div class="line">    taker.setEmpMemento(emp.memento());</div><div class="line"></div><div class="line">    <span class="comment">//备份完了后再修改</span></div><div class="line">    emp.setEname(<span class="string">"李四"</span>);</div><div class="line">    emp.setAge(<span class="number">30</span>);</div><div class="line">    emp.setSalary(<span class="number">50000</span>);</div><div class="line">    <span class="comment">//然后再次打印</span></div><div class="line">    System.out.println(<span class="string">"修改后："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line"></div><div class="line">    <span class="comment">//开始恢复</span></div><div class="line">    emp.recovery(taker.getEmpMemento());</div><div class="line">    System.out.println(<span class="string">"恢复后："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<pre><code>第一次：张三---20---4000.0

修改后：李四---30---50000.0

恢复后：张三---20---4000.0
</code></pre><p>但是，这样的效果是只能备份一次。有时候我们需要备份多个点，根据需要来还原具体哪次的数据</p>
<h5 id="多次备份"><a href="#多次备份" class="headerlink" title="多次备份"></a>多次备份</h5><p>使用Stack来存储备份数据，进行多次备份。用Stack的好处是<font color="red">Stack是后进先出的</font>，也就是说：<strong>你最近一次备份的数据会优先获取到</strong>。</p>
<p>修改管理者中的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="comment">//管理者：管理备忘录对象</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</div><div class="line">    <span class="comment">//需要管理的备忘录对象，这里也可以使用一个list容器来存储。这样可以备份多个点</span></div><div class="line">    <span class="comment">//或者使用一个Stack栈来保存，因为Stack是后进先出的</span></div><div class="line">    <span class="keyword">private</span> Stack&lt;EmpMemento&gt; stack = <span class="keyword">new</span> Stack&lt;EmpMemento&gt;();</div><div class="line">    <span class="comment">//备份emp数据到栈中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mementoEmp</span><span class="params">(EmpMemento emp)</span></span>&#123;</div><div class="line">        stack.push(emp);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//从栈中获取最近一次备份的emp数据</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EmpMemento <span class="title">getEmpForStack</span><span class="params">()</span></span>&#123;    </div><div class="line">        <span class="keyword">if</span> (!stack.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> stack.peek();<span class="comment">//peek只获取，不删除</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//从栈中获取最近一次备份的emp数据,并且从栈中删除该数据</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EmpMemento <span class="title">getEmpForStackAndRemove</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (!stack.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> stack.pop();<span class="comment">//pop获取后删除该元素</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次测试：后进先出，也就是说。恢复的话恢复的是最后一次备份的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    CareTaker taker = <span class="keyword">new</span> CareTaker();<span class="comment">//构建一个备忘录管理者</span></div><div class="line">    <span class="comment">//构建发起人</span></div><div class="line">    EmpOriginator emp = <span class="keyword">new</span> EmpOriginator(<span class="string">"张三"</span>, <span class="number">20</span>, <span class="number">4000</span>);</div><div class="line">    System.out.println(<span class="string">"第一次："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line">    <span class="comment">//第1次备份</span></div><div class="line">    taker.mementoEmp(emp.memento());</div><div class="line"></div><div class="line">    <span class="comment">//备份完了后再修改</span></div><div class="line">    emp.setEname(<span class="string">"李四"</span>);</div><div class="line">    emp.setAge(<span class="number">30</span>);</div><div class="line">    emp.setSalary(<span class="number">50000</span>);</div><div class="line">    <span class="comment">//然后再次打印</span></div><div class="line">    System.out.println(<span class="string">"1修改后："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line">    <span class="comment">//第2次备份</span></div><div class="line">    taker.mementoEmp(emp.memento());</div><div class="line"></div><div class="line">    <span class="comment">//备份完了后再修改</span></div><div class="line">    emp.setEname(<span class="string">"李四2"</span>);</div><div class="line">    emp.setAge(<span class="number">32</span>);</div><div class="line">    emp.setSalary(<span class="number">52000</span>);</div><div class="line">    <span class="comment">//然后再次打印</span></div><div class="line">    System.out.println(<span class="string">"2修改后："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line">    <span class="comment">//第3次备份</span></div><div class="line">    taker.mementoEmp(emp.memento());</div><div class="line"></div><div class="line">    <span class="comment">//备份完了后再修改</span></div><div class="line">    emp.setEname(<span class="string">"李四3"</span>);</div><div class="line">    emp.setAge(<span class="number">33</span>);</div><div class="line">    emp.setSalary(<span class="number">32000</span>);</div><div class="line">    <span class="comment">//然后再次打印</span></div><div class="line">    System.out.println(<span class="string">"3修改后："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line">    <span class="comment">//第4次备份</span></div><div class="line">    taker.mementoEmp(emp.memento());</div><div class="line"></div><div class="line">    <span class="comment">//开始恢复</span></div><div class="line">    emp.recovery(taker.getEmpForStack());<span class="comment">//恢复的是第4次备份的数据（3修改后）</span></div><div class="line">    System.out.println(<span class="string">"恢复后："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<pre><code>第一次：张三---20---4000.0

1修改后：李四---30---50000.0

2修改后：李四2---32---52000.0

3修改后：李四3---33---32000.0

恢复后：李四3---33---32000.0
</code></pre><p>当然，也可以恢复之后把它从栈中删除。</p>
<p>测试：恢复之前从栈中删除两个最近的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开始恢复</span></div><div class="line">taker.getEmpForStackAndRemove();<span class="comment">//删除最近一次的备份</span></div><div class="line">taker.getEmpForStackAndRemove();<span class="comment">//删除最近一次的备份</span></div><div class="line">emp.recovery(taker.getEmpForStack());<span class="comment">//此时获取的是原来未删除时倒数第二次的备份</span></div><div class="line">System.out.println(<span class="string">"恢复后："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div></pre></td></tr></table></figure>
<p>此时的结果就是如下：可见，这里已经把2和3给删除了</p>
<pre><code>第一次：张三---20---4000.0

1修改后：李四---30---50000.0

2修改后：李四2---32---52000.0

3修改后：李四3---33---32000.0

恢复后：李四---30---50000.0
</code></pre><h4 id="总结-应用场景"><a href="#总结-应用场景" class="headerlink" title="总结-应用场景"></a>总结-应用场景</h4><ol>
<li><p>棋类游戏中的悔棋操作</p>
</li>
<li><p>软件中的撤销操作</p>
</li>
<li><p>数据库中的事务回滚操作</p>
</li>
<li><p>常用软件中的历史记录功能</p>
</li>
</ol>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>大话设计模式(带目录完整版).pdf</li>
<li><a href="http://www.cnblogs.com/meet/p/5116407.html" target="_blank" rel="external">备忘录模式（Memento） - FangZheng - 博客园</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大话设计模式——读后感（2）&quot;&gt;&lt;a href=&quot;#大话设计模式——读后感（2）&quot; class=&quot;headerlink&quot; title=&quot;大话设计模式——读后感（2）&quot;&gt;&lt;/a&gt;&lt;center&gt;大话设计模式——读后感（2）&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;Tip2&quot;&gt;&lt;a href=&quot;#Tip2&quot; class=&quot;headerlink&quot; title=&quot;Tip2&quot;&gt;&lt;/a&gt;Tip2&lt;/h3&gt;&lt;h4 id=&quot;备忘录模式&quot;&gt;&lt;a href=&quot;#备忘录模式&quot; class=&quot;headerlink&quot; title=&quot;备忘录模式&quot;&gt;&lt;/a&gt;备忘录模式&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/527668/201601/527668-20160109144237450-356010664.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Originator（发起人）：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。&lt;/p&gt;
&lt;p&gt;Originator可根据需要决定Memento存储Originator的哪些内部状态&lt;/p&gt;
&lt;p&gt;Memento（备忘录）：负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。&lt;/p&gt;
&lt;p&gt;备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到&lt;/p&gt;
&lt;p&gt;先前状态所需的所有数据。&lt;/p&gt;
&lt;p&gt;Caretaker（管理者）：负责保存好备忘录Memento，不能对备忘录的内存进行操作或检查。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://ymjava.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="http://ymjava.cn/archives/b585e161.html"/>
    <id>http://ymjava.cn/archives/b585e161.html</id>
    <published>2017-11-01T04:48:10.000Z</published>
    <updated>2017-11-09T06:58:14.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a><center>新的开始</center></h2><h3 id="初整理-——-大话设计模式Tip1-读后笔记"><a href="#初整理-——-大话设计模式Tip1-读后笔记" class="headerlink" title="初整理 ——  大话设计模式Tip1 读后笔记"></a>初整理 ——  大话设计模式Tip1 读后笔记</h3><h4 id="UML类图整理"><a href="#UML类图整理" class="headerlink" title="UML类图整理"></a>UML类图整理</h4><p><img src="https://s1.ax2x.com/2017/11/06/Bfzu3.png" alt="Bfzu3.png"></p>
<p>动物类 (‘+’ 表示public ，’-‘ 表示private，’#’表示protected)</p>
<ul>
<li>第一层类的名称 (抽象类是用斜体表示)</li>
<li>第二层类的特性</li>
<li>第三层类的函数方法</li>
</ul>
<p>飞翔 接口图</p>
<ul>
<li>顶层是\&lt;<interface\>&gt;显示</interface\></li>
<li>第二层是方法<a id="more"></a>
另一种接口表现法是棒棒糖表示法（表现的唐老鸭实现了‘讲人话’的方法）。</li>
</ul>
<ul>
<li>继承：空心三角形+实线 表示。</li>
<li>实现：空心三角形+虚线 表示。</li>
<li>关联：实线箭头 表示。</li>
<li>聚合：空心的菱形+实线箭头 表示。（聚合表示一种弱的‘拥有关系’，体现的是A对象可以包含B对象，但B对象不是A对象的一部分[DPE]）</li>
<li>合成：菱形+实线箭头，两端数字为基数，表示一端的类可以有几个实例。（合成是一种强的拥有关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样）</li>
<li>依赖：虚线箭头表示。</li>
</ul>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简单工厂模式：用一个单独的类来做这个创造实例的过程。</p>
<p><img src="https://s1.ax2x.com/2017/11/06/BfO8z.png" alt="BfO8z.png"></p>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>策略模式：是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。</p>
<p>策略模式的Strategy 类层次为Context 定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能，</p>
<p>策略模式的另一个优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。</p>
<p>当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy 类中，可以在使用这些行为的类中消除条件语句。</p>
<p>策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。（在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象。）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;新的开始&quot;&gt;&lt;a href=&quot;#新的开始&quot; class=&quot;headerlink&quot; title=&quot;新的开始&quot;&gt;&lt;/a&gt;&lt;center&gt;新的开始&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;初整理-——-大话设计模式Tip1-读后笔记&quot;&gt;&lt;a href=&quot;#初整理-——-大话设计模式Tip1-读后笔记&quot; class=&quot;headerlink&quot; title=&quot;初整理 ——  大话设计模式Tip1 读后笔记&quot;&gt;&lt;/a&gt;初整理 ——  大话设计模式Tip1 读后笔记&lt;/h3&gt;&lt;h4 id=&quot;UML类图整理&quot;&gt;&lt;a href=&quot;#UML类图整理&quot; class=&quot;headerlink&quot; title=&quot;UML类图整理&quot;&gt;&lt;/a&gt;UML类图整理&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2017/11/06/Bfzu3.png&quot; alt=&quot;Bfzu3.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;动物类 (‘+’ 表示public ，’-‘ 表示private，’#’表示protected)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一层类的名称 (抽象类是用斜体表示)&lt;/li&gt;
&lt;li&gt;第二层类的特性&lt;/li&gt;
&lt;li&gt;第三层类的函数方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;飞翔 接口图&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶层是\&amp;lt;&lt;interface\&gt;&amp;gt;显示&lt;/li&gt;
&lt;li&gt;第二层是方法
    
    </summary>
    
      <category term="设计模式" scheme="http://ymjava.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Let&#39;s Encrypt证书使用</title>
    <link href="http://ymjava.cn/archives/ec1907ff.html"/>
    <id>http://ymjava.cn/archives/ec1907ff.html</id>
    <published>2017-06-08T02:55:52.000Z</published>
    <updated>2017-11-02T06:03:09.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Let’s-Encrypt证书使用"><a href="#Let’s-Encrypt证书使用" class="headerlink" title="Let’s Encrypt证书使用"></a><center>Let’s Encrypt证书使用<center></center></center></h2><blockquote>
<p>certbot软件从Github直接下载，在CentOS6、7下执行都没有问题。</p>
</blockquote>
<h3 id="设置yum代码库"><a href="#设置yum代码库" class="headerlink" title="设置yum代码库"></a>设置yum代码库</h3><ul>
<li>certbot-auto运行是会自动连接下载依赖包，启用163(<a href="http://mirrors.163.com/.help/centos.html" target="_blank" rel="external">http://mirrors.163.com/.help/centos.html</a>) 和epel(<a href="https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F)库，提前准备好环境，更多查看https://certbot.eff.org/#centosrhel6-other" target="_blank" rel="external">https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F)库，提前准备好环境，更多查看https://certbot.eff.org/#centosrhel6-other</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</div><div class="line">2.mv CentOS6-Base-163.repo /etc/yum.repos.d/</div><div class="line">3.wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm</div><div class="line">4.rpm -ivh epel-release-latest-6.noarch.rpm</div></pre></td></tr></table></figure>
<p>修改CentOS6-Base-163.repo文件，将$releasever替换为6<br>修改epel.repo文件，将$releasever替换为6，将<a href="http://download.fedoraproject.org/pub/epel修改为https://mirrors.tuna.tsinghua.edu.cn/epel" target="_blank" rel="external">http://download.fedoraproject.org/pub/epel修改为https://mirrors.tuna.tsinghua.edu.cn/epel</a><br>运行以下命令生成缓存</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum clean all</div><div class="line">yum makecache</div></pre></td></tr></table></figure>
<p>安装git软件，也可直接从<a href="https://github.com/certbot/certbot下载" target="_blank" rel="external">https://github.com/certbot/certbot下载</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install git</div></pre></td></tr></table></figure></p>
<a id="more"></a> 
<h3 id="防火墙修改"><a href="#防火墙修改" class="headerlink" title="防火墙修改"></a>防火墙修改</h3><p>修改/etc/sysconfig/iptables<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysconfig/iptables</div></pre></td></tr></table></figure></p>
<p>查看是否有80、443端口允许访问记录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-A INPUT -i eth0 -p tcp -m tcp --dport 80 -j ACCEPT</div><div class="line">-A INPUT -i eth0 -p tcp -m tcp --dport 443 -j ACCEPT</div></pre></td></tr></table></figure></p>
<h3 id="获取Let’s-Encrypt证书"><a href="#获取Let’s-Encrypt证书" class="headerlink" title="获取Let’s Encrypt证书"></a>获取Let’s Encrypt证书</h3><p>certbot-auto运行是会自动连接下载依赖包，执行过程出现问题具体分析原因<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/certbot/certbot</div><div class="line"><span class="built_in">cd</span> certbot</div></pre></td></tr></table></figure></p>
<p>certbot-auto命令在root用户下执行，certbot-auto会执行更新certbot版本和安装依赖包，执行需要联网，有时较慢<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./certbot-auto certonly --standalone --email 你的邮箱 <span class="_">-d</span> 你的域名</div></pre></td></tr></table></figure></p>
<p>生成的证书放在/etc/letsencrypt/live/[网站域名]下，证书有效期3个月</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>cert.pem</td>
<td>服务端证书</td>
</tr>
<tr>
<td>chain.pem</td>
<td>浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书</td>
</tr>
<tr>
<td>fullchain.pem</td>
<td>包括了cert.pem和chain.pem的内容</td>
</tr>
<tr>
<td>privkey.pem</td>
<td>证书的私钥</td>
</tr>
</tbody>
</table>
<h3 id="Apache-设置"><a href="#Apache-设置" class="headerlink" title="Apache 设置"></a>Apache 设置</h3><p>Apache测试版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Server version: Apache/2.4.6 (CentOS)</div><div class="line">Server built:   Nov 14 2016 18:04:44</div></pre></td></tr></table></figure>
<p>修改/etc/httpd/conf.d/ssl.conf<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Listen 443 https</div><div class="line">&lt;VirtualHost _default_:443&gt;</div><div class="line">Header always <span class="built_in">set</span> Strict-Transport-Security <span class="string">"max-age=63072000; includeSubdomains; preload"</span></div><div class="line">SSLEngine on</div><div class="line">SSLCertificateFile /etc/letsencrypt/live/域名/cert.pem</div><div class="line">SSLCertificateKeyFile /etc/letsencrypt/live/域名/privkey.pem</div><div class="line">SSLCertificateChainFile /etc/letsencrypt/live/域名/fullchain.pem</div><div class="line">&lt;/VirtualHost&gt;</div></pre></td></tr></table></figure></p>
<p>HSTS（HTTP Strict Transport Security）的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。</p>
<h3 id="Tomcat设置"><a href="#Tomcat设置" class="headerlink" title="Tomcat设置"></a>Tomcat设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cp /etc/letsencrypt/live/域名/*.pem apache-tomcat-8.5.5/conf/</div><div class="line"><span class="built_in">cd</span> apache-tomcat-8.5.5/conf/</div><div class="line">chown 用户:组 *.pem</div></pre></td></tr></table></figure>
<p>修改conf/server.xml文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;Connector port=<span class="string">"8443"</span> protocol=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span></div><div class="line">           maxThreads=<span class="string">"150"</span> SSLEnabled=<span class="string">"true"</span> &gt;</div><div class="line">    &lt;UpgradeProtocol className=<span class="string">"org.apache.coyote.http2.Http2Protocol"</span> /&gt;</div><div class="line">    &lt;SSLHostConfig&gt;</div><div class="line">        &lt;Certificate certificateKeyFile=<span class="string">"conf/privkey.pem"</span></div><div class="line">                     certificateFile=<span class="string">"conf/cert.pem"</span></div><div class="line">                     certificateChainFile=<span class="string">"conf/fullchain.pem"</span></div><div class="line">                     <span class="built_in">type</span>=<span class="string">"RSA"</span> /&gt;</div><div class="line">    &lt;/SSLHostConfig&gt;</div><div class="line">&lt;/Connector&gt;</div></pre></td></tr></table></figure>
<h3 id="Nginx设置"><a href="#Nginx设置" class="headerlink" title="Nginx设置"></a>Nginx设置</h3><p>修改nginx的配置文件/usr/local/nginx/conf/nginx.conf，实现https转到内网tomcat的http服务，注：以下配置未实现tomcat识别来自https的请求，详细见问题3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">     listen 8443;</div><div class="line">     server_name localhost;</div><div class="line">     ssl on;</div><div class="line">     ssl_certificate /etc/letsencrypt/live/域名/fullchain.pem;</div><div class="line">     ssl_certificate_key /etc/letsencrypt/live/域名/privkey.pem;</div><div class="line">     server_name_in_redirect off;</div><div class="line">     proxy_set_header Host $host:$server_port;</div><div class="line">     proxy_connect_timeout 60s;</div><div class="line">     proxy_read_timeout 5400s;</div><div class="line">     proxy_send_timeout 5400s;</div><div class="line">     proxy_set_header X-Real-IP $remote_addr;</div><div class="line">     proxy_set_header REMOTE-HOST $remote_addr;</div><div class="line">     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line">     index index.html index.htm index.jsp index.do;</div><div class="line">     location ^~ /ZhsqApp/&#123;</div><div class="line">         proxy_pass  http://192.168.100.10:8080;</div><div class="line">         client_max_body_size    100m;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="Weblogic-配置"><a href="#Weblogic-配置" class="headerlink" title="Weblogic 配置"></a>Weblogic 配置</h3><p>weblogic必须是10.3.6及以上版本，才能使用Let’s Encrypt的证书，Let’s Encrypt采用SHA256withRSA，低版本的不支持SHA256withRSA</p>
<h3 id="生成密钥库"><a href="#生成密钥库" class="headerlink" title="生成密钥库"></a>生成密钥库</h3><p>执行openssl命令生成fullchain_and_key.p12，执行keytool命令生成密钥库文件weblogic.jks</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">openssl pkcs12 -export -in fullchain.pem -inkey privkey.pem -out fullchain_and_key.p12 -name weblogic -passout pass:123456</div><div class="line">keytool -importkeystore -deststorepass 123456   -destkeystore weblogic.jks -srckeystore fullchain_and_key.p12 -srcstoretype PKCS12 -srcstorepass 123456  -alias weblogic</div></pre></td></tr></table></figure>
<p>privkey.pem、fullchain.pem为Let’s Encrypt生成文件，密码可自行修改。注-name与-alias别名保存一致，-passout参数的pass:需保留。-passout与-srcstorepass密码保持一致， -deststorepass需记住在weblogic配置使用。</p>
<h3 id="生成信任库"><a href="#生成信任库" class="headerlink" title="生成信任库"></a>生成信任库</h3><p>执行keytool命令生成信任库文件trust.jks<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -importcert -alias rootCA -trustcacerts -file cert.pem -keystore trust.jks -storepass 123456</div></pre></td></tr></table></figure></p>
<p>cert.pem为Let’s Encrypt生成文件，密码可自行修改。 -storepass需记住在weblogic配置使用。</p>
<h3 id="weblogic配置"><a href="#weblogic配置" class="headerlink" title="weblogic配置"></a>weblogic配置</h3><h4 id="启用SSL监听端口"><a href="#启用SSL监听端口" class="headerlink" title="启用SSL监听端口"></a>启用SSL监听端口</h4><p>登录weblogic控制台 -&gt; 服务器 -&gt; 选择服务器管理 -&gt; 配置标签 -&gt; 一般信息子标签页 -&gt; 启用 SSL 监听端口 -&gt; 修改端口7002 -&gt; 保存</p>
<p>在Linux下设置端口小于1024的，需要使用管理员用户启动weblogic。</p>
<p><img src="http://f3e6036a.fromwiz.com/share/resources/b0c2bbb1-1a90-4b45-a09a-c7aa9804cd7c/index_files/64659649.png" alt=""></p>
<h4 id="密钥库配置"><a href="#密钥库配置" class="headerlink" title="密钥库配置"></a>密钥库配置</h4><p>进入配置标签 -&gt; 密钥库标签页</p>
<p>1.密钥库点更改，选择定制标识和定制信任，点击保存。<br>2.定制标识密钥库，填写weblogic.jks全路径<br>定制标识密钥库类型，填写jks<br>3.定制标识密钥库密码短语，填写生成密钥库时 -deststorepass写的密码<br>4.确认定制标识密钥库密码短语，填写生成密钥库时 -deststorepass写的密码<br>5.定制信任密钥库，填写trust.jks全路径<br>6.定制信任密钥库类型，填写jks<br>7.定制信任密钥库密码短语，填写生成信任库时 -storepass写的密码<br>8.确认定制信任密钥库密码短语，填写生成信任库时 -storepass写的密码</p>
<p><img src="http://f3e6036a.fromwiz.com/share/resources/b0c2bbb1-1a90-4b45-a09a-c7aa9804cd7c/index_files/65091944.png" alt=""></p>
<h4 id="SSL配置"><a href="#SSL配置" class="headerlink" title="SSL配置"></a>SSL配置</h4><p>进入配置标签 -&gt; SSL标签页</p>
<p>1.私有密钥别名，填写生成密钥库时的别名<br>2.私有密钥密码短语，填写生成密钥库时 -deststorepass写的密码<br>3.确认私有密钥密码短语，填写生成密钥库时 -deststorepass写的密码<br>点击保存</p>
<p><img src="http://f3e6036a.fromwiz.com/share/resources/b0c2bbb1-1a90-4b45-a09a-c7aa9804cd7c/index_files/65673128.png" alt=""></p>
<p>weblogic 10.3. 6 版本还需要做额外配置，SSL标签页中，点击高级，选中使用 JSSE SSL，点击保存</p>
<p><img src="http://f3e6036a.fromwiz.com/share/resources/b0c2bbb1-1a90-4b45-a09a-c7aa9804cd7c/index_files/65716484.png" alt=""></p>
<p>重启weblogic服务，测试https访问。</p>
<h3 id="更新证书"><a href="#更新证书" class="headerlink" title="更新证书"></a>更新证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./certbot-auto renew</div></pre></td></tr></table></figure>
<p>更新证书之后，需要执行tomcat、weblogic对应配置内容。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="问题1、Let’s-Encrypt安装好之后在PC端可以正常访问，但在手机端提示不受信任的"><a href="#问题1、Let’s-Encrypt安装好之后在PC端可以正常访问，但在手机端提示不受信任的" class="headerlink" title="问题1、Let’s Encrypt安装好之后在PC端可以正常访问，但在手机端提示不受信任的"></a>问题1、Let’s Encrypt安装好之后在PC端可以正常访问，但在手机端提示不受信任的</h4><p>主要原因是缺少中级证书。生成的LE证书后使用的需要使用fullchain.pem，打开后会发现有两段证书，第一段是LE的证书，第二段才是你网站的证书。而你只有网站的证书，而没有LE的证书。</p>
<h4 id="问题2、如何关闭SSL3协议"><a href="#问题2、如何关闭SSL3协议" class="headerlink" title="问题2、如何关闭SSL3协议"></a>问题2、如何关闭SSL3协议</h4><p>查看<a href="http://disablessl3.com如何关闭apache、nginx的ssl3协议" target="_blank" rel="external">http://disablessl3.com如何关闭apache、nginx的ssl3协议</a><br>tomcat修改，修改server.xml,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</div><div class="line">               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot;</div><div class="line">               sslProtocol=&quot;TLS&quot; sslEnabledProtocols=&quot;TLSv1,TLSv1.1,TLSv1.2&quot;  &gt;</div></pre></td></tr></table></figure>
<h4 id="问题3、nginx采用Let’s-Encrypt证书，如何实现https转http，后端识别来自https的请求"><a href="#问题3、nginx采用Let’s-Encrypt证书，如何实现https转http，后端识别来自https的请求" class="headerlink" title="问题3、nginx采用Let’s Encrypt证书，如何实现https转http，后端识别来自https的请求"></a>问题3、nginx采用Let’s Encrypt证书，如何实现https转http，后端识别来自https的请求</h4><p>1.修改nginx的配置文件<br>修改nginx的配置文件/usr/local/nginx/conf/nginx.conf，实现https转到内网tomcat的http服务，注：以下配置未实现tomcat识别来自https的请求，详细见问题2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 8443;</div><div class="line">    server_name localhost;</div><div class="line">    ssl on;</div><div class="line">    ssl_certificate /etc/letsencrypt/live/域名/fullchain.pem;</div><div class="line">    ssl_certificate_key /etc/letsencrypt/live/域名/privkey.pem;</div><div class="line">    server_name_in_redirect off;</div><div class="line">    proxy_set_header Host $host:$server_port;</div><div class="line">    proxy_connect_timeout 60s;</div><div class="line">    proxy_read_timeout 5400s;</div><div class="line">    proxy_send_timeout 5400s;</div><div class="line">    proxy_set_header X-Real-IP $remote_addr;</div><div class="line">    proxy_set_header REMOTE-HOST $remote_addr;</div><div class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line">              proxy_set_header X-Forwarded-Proto  $scheme;</div><div class="line">              proxy_set_header WL-Proxy-SSL true;</div><div class="line">              add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains;   &quot;;</div><div class="line">    index index.html index.htm index.jsp index.do;</div><div class="line">    location ^~ /ZhsqApp/&#123;</div><div class="line">        proxy_pass  http://192.168.100.10:8080;</div><div class="line">        client_max_body_size    100m;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>主要增加3处配置：</p>
<blockquote>
<p>proxy_set_header X-Forwarded-Proto  $scheme; tomcat可识别参数<br>proxy_set_header WL-Proxy-SSL true; weblogic可识别参数<br>add_header Strict-Transport-Security “max-age=63072000; includeSubdomains; “; 启用HSTS功能，浏览器在63072000秒时间内默认以https请求服务</p>
</blockquote>
<p>2.tomcat启用识别X-Forwarded-Proto设置<br>修改配置文件server.xml，在Engine下添加下面内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Valve className=&quot;org.apache.catalina.valves.RemoteIpValve&quot;   remoteIpHeader=&quot;X-Forwarded-For&quot;</div><div class="line">           protocolHeader=&quot;X-Forwarded-Proto&quot;</div><div class="line">           protocolHeaderHttpsValue=&quot;https&quot;/&gt;</div></pre></td></tr></table></figure>
<p>做好上述配置，重启tomcat。request.getScheme()的值显示https<br>另外，可参考Nginx SSL+tomcat集群,request.getScheme() 取到https正确的协议内容</p>
<p>3.weblogic启用识别WL-Proxy-SSL 设置<br>进入console界面，域名-&gt;配置-&gt;Web应用程序，勾选启用 WebLogic 插件，保存</p>
<p><img src="http://f3e6036a.fromwiz.com/share/resources/b0c2bbb1-1a90-4b45-a09a-c7aa9804cd7c/index_files/65317389.png" alt=""><br><img src="http://f3e6036a.fromwiz.com/share/resources/b0c2bbb1-1a90-4b45-a09a-c7aa9804cd7c/index_files/65382741.png" alt=""></p>
<p>做好上述配置，重启weblogic。request.getScheme()的值显示https<br>另外，可参考HTTPS/SSL/Spring Security doesn’t work in both a load balancer and non-load balancer environment #424内容</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Let’s-Encrypt证书使用&quot;&gt;&lt;a href=&quot;#Let’s-Encrypt证书使用&quot; class=&quot;headerlink&quot; title=&quot;Let’s Encrypt证书使用&quot;&gt;&lt;/a&gt;&lt;center&gt;Let’s Encrypt证书使用&lt;center&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;certbot软件从Github直接下载，在CentOS6、7下执行都没有问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;设置yum代码库&quot;&gt;&lt;a href=&quot;#设置yum代码库&quot; class=&quot;headerlink&quot; title=&quot;设置yum代码库&quot;&gt;&lt;/a&gt;设置yum代码库&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;certbot-auto运行是会自动连接下载依赖包，启用163(&lt;a href=&quot;http://mirrors.163.com/.help/centos.html&quot;&gt;http://mirrors.163.com/.help/centos.html&lt;/a&gt;) 和epel(&lt;a href=&quot;https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F)库，提前准备好环境，更多查看https://certbot.eff.org/#centosrhel6-other&quot;&gt;https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F)库，提前准备好环境，更多查看https://certbot.eff.org/#centosrhel6-other&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1.wget http://mirrors.163.com/.help/CentOS6-Base-163.repo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2.mv CentOS6-Base-163.repo /etc/yum.repos.d/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3.wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4.rpm -ivh epel-release-latest-6.noarch.rpm&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;修改CentOS6-Base-163.repo文件，将$releasever替换为6&lt;br&gt;修改epel.repo文件，将$releasever替换为6，将&lt;a href=&quot;http://download.fedoraproject.org/pub/epel修改为https://mirrors.tuna.tsinghua.edu.cn/epel&quot;&gt;http://download.fedoraproject.org/pub/epel修改为https://mirrors.tuna.tsinghua.edu.cn/epel&lt;/a&gt;&lt;br&gt;运行以下命令生成缓存&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;yum clean all&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;yum makecache&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;安装git软件，也可直接从&lt;a href=&quot;https://github.com/certbot/certbot下载&quot;&gt;https://github.com/certbot/certbot下载&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;yum install git&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术随记" scheme="http://ymjava.cn/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>spring ioc 控制反转</title>
    <link href="http://ymjava.cn/archives/50de3585.html"/>
    <id>http://ymjava.cn/archives/50de3585.html</id>
    <published>2017-03-04T13:15:00.000Z</published>
    <updated>2017-11-01T09:32:20.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-–-IOC"><a href="#Spring-–-IOC" class="headerlink" title="Spring – IOC"></a><center>Spring – IOC<center></center></center></h2><h3 id="spring-ioc-控制反转"><a href="#spring-ioc-控制反转" class="headerlink" title="spring ioc 控制反转"></a>spring ioc 控制反转</h3><pre><code>IOC（Inversion of Control）控制反转：本来是由应用程序管理的对象之间的依赖关系，现在交给了容器管理，这就叫控制反转，即交给了IOC容器，Spring的IOC容器主要使用DI方式实现的。不需要主动查找，对象的查找、定位和创建全部由容器管理。

通俗点说就是不创建对象。以前我们要调用一个对象的方法，首先要new一个对象。但使用IOC容器，在代码中不直接与对象连接，而是在配置文件中描述要使用哪一个对象。容器负责将这些联系在一起。
</code></pre><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><pre><code>IOC容器的对象实例化是通过配置文件来实现的。术语上这叫做注入。注入有两种形式，采用构造方法注入和采用setter注入。具体的注入形式如下
</code></pre><a id="more"></a> 
<p>采用set方法注入，给属性添加一个set方法，并对其进行赋值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">publicclass UserManagerImplimplements UserManager &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> UserDaouserDao;</div><div class="line"></div><div class="line">    <span class="function">publicvoid <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.userDao = userDao;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;beanid="userManager"class="com.bjpowernode.spring.manager.UserManagerImpl"&gt;</div><div class="line"></div><div class="line">     &lt;propertyname="userDao"ref="usrDao4Oracle"/&gt;</div><div class="line"></div><div class="line">  &lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>set注入特点：</p>
<pre><code> 与传统的JavaBean的写法更相似，程序员更容易理解、接受，通过setter方式设定依赖关系显得更加直观、明显；

 对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致死你功能下降。而使用设置注入，则避免这下问题；

尤其在某些属性可选的情况下，多参数的构造器更加笨拙。
</code></pre><p>采用构造方法注入，在构造方法中对属性进行赋值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">publicclass UserManagerImplimplements UserManager &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> UserDaouserDao;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserManagerImpl</span><span class="params">(UserDao userDao)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.userDao = userDao;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置文件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;beanid="userManager"class="com.bjpowernode.spring.manager.UserManagerImpl"&gt;</div><div class="line"></div><div class="line">    &lt;constructor-argref="userDao4Mysql"/&gt;</div><div class="line"></div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>构造方法注入特点：</p>
<pre><code> 构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。

 对于依赖关系无须变化的Bean，构造注入更有用处；因为没有setter方法，所有的依赖关系全部在构造器内设定，因此，不用担心后续代码对依赖关系的破坏。
依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系。对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则；
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-–-IOC&quot;&gt;&lt;a href=&quot;#Spring-–-IOC&quot; class=&quot;headerlink&quot; title=&quot;Spring – IOC&quot;&gt;&lt;/a&gt;&lt;center&gt;Spring – IOC&lt;center&gt;&lt;/h2&gt;&lt;h3 id=&quot;spring-ioc-控制反转&quot;&gt;&lt;a href=&quot;#spring-ioc-控制反转&quot; class=&quot;headerlink&quot; title=&quot;spring ioc 控制反转&quot;&gt;&lt;/a&gt;spring ioc 控制反转&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;IOC（Inversion of Control）控制反转：本来是由应用程序管理的对象之间的依赖关系，现在交给了容器管理，这就叫控制反转，即交给了IOC容器，Spring的IOC容器主要使用DI方式实现的。不需要主动查找，对象的查找、定位和创建全部由容器管理。

通俗点说就是不创建对象。以前我们要调用一个对象的方法，首先要new一个对象。但使用IOC容器，在代码中不直接与对象连接，而是在配置文件中描述要使用哪一个对象。容器负责将这些联系在一起。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;实现方法&quot;&gt;&lt;a href=&quot;#实现方法&quot; class=&quot;headerlink&quot; title=&quot;实现方法&quot;&gt;&lt;/a&gt;实现方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;IOC容器的对象实例化是通过配置文件来实现的。术语上这叫做注入。注入有两种形式，采用构造方法注入和采用setter注入。具体的注入形式如下
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="java学习之路" scheme="http://ymjava.cn/categories/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="java" scheme="http://ymjava.cn/tags/java/"/>
    
      <category term="IOC（Inversion of Control）控制反转" scheme="http://ymjava.cn/tags/IOC%EF%BC%88Inversion-of-Control%EF%BC%89%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>js学习之promise</title>
    <link href="http://ymjava.cn/archives/fddbb00f.html"/>
    <id>http://ymjava.cn/archives/fddbb00f.html</id>
    <published>2017-02-21T11:01:28.000Z</published>
    <updated>2017-11-01T09:32:28.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js学习之promise"><a href="#js学习之promise" class="headerlink" title="js学习之promise"></a><center>js学习之promise<center></center></center></h2><h3 id="Promise的初步认识"><a href="#Promise的初步认识" class="headerlink" title="Promise的初步认识"></a>Promise的初步认识</h3><p>我们之前在完成异步执行都是利用的回调函数去实现的，例如ajax的调用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 新建XMLHttpRequest对象</span></div><div class="line"></div><div class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></div><div class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></div><div class="line">        <span class="comment">// 判断响应结果:</span></div><div class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</div><div class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></div><div class="line">            <span class="keyword">return</span> success(request.responseText);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></div><div class="line">            <span class="keyword">return</span> fail(request.status);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// HTTP请求还在继续...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 发送请求:</span></div><div class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/api/categories'</span>);</div><div class="line">request.send();</div><div class="line"></div><div class="line">alert(<span class="string">'请求已发送，请等待响应...'</span>);</div></pre></td></tr></table></figure></p>
<a id="more"></a> 
<p>当然我们可以封装起来，改成另外的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ajax = ajaxGet(<span class="string">'http://...'</span>);</div><div class="line">ajax.ifSuccess(success)</div><div class="line">    .ifFail(fail);</div></pre></td></tr></table></figure></p>
<p>但是我们从ES6后我们有了新的写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(test).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'成功：'</span> + result);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'失败：'</span> + reason);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当然这只是简单的promise的利用，进阶版本请看参考链接。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>&gt;<br>1.<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000" target="_blank" rel="external">Promise - 廖雪峰的官方网站</a><br>2.<a href="http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/" target="_blank" rel="external">[翻译] We have a problem with promises - FEX</a><br>3.<a href="http://liubin.org/promises-book/" target="_blank" rel="external">JavaScript Promise迷你书（中文版）</a></p>
<hr>
<h3 id="前方的路很长，还需努力啊"><a href="#前方的路很长，还需努力啊" class="headerlink" title="前方的路很长，还需努力啊"></a>前方的路很长，还需努力啊</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;js学习之promise&quot;&gt;&lt;a href=&quot;#js学习之promise&quot; class=&quot;headerlink&quot; title=&quot;js学习之promise&quot;&gt;&lt;/a&gt;&lt;center&gt;js学习之promise&lt;center&gt;&lt;/h2&gt;&lt;h3 id=&quot;Promise的初步认识&quot;&gt;&lt;a href=&quot;#Promise的初步认识&quot; class=&quot;headerlink&quot; title=&quot;Promise的初步认识&quot;&gt;&lt;/a&gt;Promise的初步认识&lt;/h3&gt;&lt;p&gt;我们之前在完成异步执行都是利用的回调函数去实现的，例如ajax的调用：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; request = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; XMLHttpRequest(); &lt;span class=&quot;comment&quot;&gt;// 新建XMLHttpRequest对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;request.onreadystatechange = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;// 状态发生变化时，函数被回调&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (request.readyState === &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 成功完成&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 判断响应结果:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (request.status === &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 成功，通过responseText拿到响应的文本:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; success(request.responseText);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 失败，根据响应码判断失败原因:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fail(request.status);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// HTTP请求还在继续...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 发送请求:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;request.open(&lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;/api/categories&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;request.send();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(&lt;span class=&quot;string&quot;&gt;&#39;请求已发送，请等待响应...&#39;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js学习之路" scheme="http://ymjava.cn/categories/js%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="js" scheme="http://ymjava.cn/tags/js/"/>
    
      <category term="nodejs" scheme="http://ymjava.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>travis部署Hexo之填坑日记</title>
    <link href="http://ymjava.cn/archives/a8653e18.html"/>
    <id>http://ymjava.cn/archives/a8653e18.html</id>
    <published>2017-02-17T08:34:46.000Z</published>
    <updated>2017-11-01T09:32:36.729Z</updated>
    
    <content type="html"><![CDATA[<p>这个小客栈总算是被我搭起来了，前前后后遇到了不少坑。果然每一次在网上学东西都是遇坑填坑的过程，不过这都是为了我们更好的成（zhuang）长(bi)嘛。</p>
<p>也就不重复的讲其他教程里有的内容了，只简明的记录下，我的填坑过程。</p>
<h3 id="第一个坑-travis-找不指定文件"><a href="#第一个坑-travis-找不指定文件" class="headerlink" title="第一个坑 travis 找不指定文件"></a>第一个坑 travis 找不指定文件</h3><a id="more"></a> 
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> 博客项目文件夹根目录</div><div class="line">$ touch .travis.yml</div></pre></td></tr></table></figure>
<ul>
<li>登录 travis<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">travis login --auto</div><div class="line">`</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这里的 REPO_TOKEN 是变量名,在后面的配置文件中会用到</span></div><div class="line"><span class="comment"># TOKEN 是上面github生成的Token</span></div><div class="line">travis encrypt <span class="string">'REPO_TOKEN=&lt;TOKEN&gt;'</span> --add</div></pre></td></tr></table></figure>
<p>这在很多讲解Travis部署Hexo的教程中都有的步骤，那么问题就出现了。。。。</p>
<ul>
<li>travis 找不到指定文件</li>
</ul>
<p>这里是在travis encrypt 你的github创建的token的时候出现的。</p>
<p>解决办法： 在travis encrypt ‘REPO_TOKEN=<token>‘ –add 的时候加上 -r 你的github用户民/你的repo名。比如我的就是</token></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">travis encrypt <span class="string">'REPO_TOKEN=&lt;TOKEN&gt;'</span> --add -r Nanmen/nanmen.github.io</div></pre></td></tr></table></figure>
<h3 id="第二个坑-travis-构建你的工程时报2-gt-dev-null错的问题"><a href="#第二个坑-travis-构建你的工程时报2-gt-dev-null错的问题" class="headerlink" title="第二个坑 travis 构建你的工程时报2&gt; dev/null错的问题"></a>第二个坑 travis 构建你的工程时报2&gt; dev/null错的问题</h3><ul>
<li>当我兴高采烈的去推送到我的dev分支的时候，travis 运行测试过程中报出个 ‘\<token> 2&gt;dev/null’ 的错误，一脸懵有没有，明明都是按照教程来的，怎么会是这样的呢。在我前后回想之后，一不小心测试出来了。。。。</token></li>
</ul>
<p>解决办法： 在你执行travis encrypt 的时候，并不是跟大部分教程写的那样，应该执行这一句<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">travis encrypt REPO_TOKEN=TOKEN --add -r Nanmen/nanmen.github.io</div></pre></td></tr></table></figure></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://www.jianshu.com/p/f4cc5866946b" target="_blank" rel="external">手把手教从零开始在GitHub上使用Hexo搭建博客教程(一)-附GitHub注册及配置 - 简书</a><br>  2.<a href="http://www.jianshu.com/p/fff7b3384f46" target="_blank" rel="external">手把手教从零开始在GitHub上使用Hexo搭建博客教程(四)-使用Travis自动部署Hex… - 简书</a><br>  3.<a href="http://blog.csdn.net/xuezhisdc/article/details/53130423" target="_blank" rel="external">hexo教程系列——使用Travis自动部署hexo - 张学志の博客 - 博客频道 - CSDN.NET</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个小客栈总算是被我搭起来了，前前后后遇到了不少坑。果然每一次在网上学东西都是遇坑填坑的过程，不过这都是为了我们更好的成（zhuang）长(bi)嘛。&lt;/p&gt;
&lt;p&gt;也就不重复的讲其他教程里有的内容了，只简明的记录下，我的填坑过程。&lt;/p&gt;
&lt;h3 id=&quot;第一个坑-travis-找不指定文件&quot;&gt;&lt;a href=&quot;#第一个坑-travis-找不指定文件&quot; class=&quot;headerlink&quot; title=&quot;第一个坑 travis 找不指定文件&quot;&gt;&lt;/a&gt;第一个坑 travis 找不指定文件&lt;/h3&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://ymjava.cn/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="http://ymjava.cn/tags/hexo/"/>
    
  </entry>
  
</feed>
