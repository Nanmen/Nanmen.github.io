<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>在路上 - easy life</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ymjava.cn/"/>
  <updated>2017-11-09T07:05:15.069Z</updated>
  <id>http://ymjava.cn/</id>
  
  <author>
    <name>南风</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记推送失败——git命令之ssh-add学习</title>
    <link href="http://ymjava.cn/archives/e8996bd7.html"/>
    <id>http://ymjava.cn/archives/e8996bd7.html</id>
    <published>2017-11-09T02:51:05.000Z</published>
    <updated>2017-11-09T07:05:15.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推送失败——git命令学习"><a href="#推送失败——git命令学习" class="headerlink" title="推送失败——git命令学习"></a><center>推送失败——git命令学习</center></h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>昨天更新文档推送设计模式的笔记，在git bash 命令框下输入以前的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g <span class="_">-d</span></div></pre></td></tr></table></figure>
<p>却给我报了个错误,<strong>Could not open a connection to your authentication agent</strong>，一翻百度发现解决方法如下：<br><a id="more"></a></p>
<blockquote>
<p>1.exec ssh-agent bash<br>2.eval ssh-agent -s<br>3.ssh-add “C:\Users\Administrator.ssh\id_rsa”</p>
</blockquote>
<p>将相应的秘钥地址改为你自己的地址，然后就可以愉快的输入测试命令了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div><div class="line">ssh -T git@git.coding.net</div></pre></td></tr></table></figure>
<p>测试通过，ok，然后就可以输入部署命令了。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="http://www.jianshu.com/p/1adbd697b249" target="_blank" rel="external">win下给 Git Bash 添加私钥时ssh-add报错的解决办法</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;推送失败——git命令学习&quot;&gt;&lt;a href=&quot;#推送失败——git命令学习&quot; class=&quot;headerlink&quot; title=&quot;推送失败——git命令学习&quot;&gt;&lt;/a&gt;&lt;center&gt;推送失败——git命令学习&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h3&gt;&lt;p&gt;昨天更新文档推送设计模式的笔记，在git bash 命令框下输入以前的&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;hexo g &lt;span class=&quot;_&quot;&gt;-d&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;却给我报了个错误,&lt;strong&gt;Could not open a connection to your authentication agent&lt;/strong&gt;，一翻百度发现解决方法如下：&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://ymjava.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>大话设计模式——读后感（2）</title>
    <link href="http://ymjava.cn/archives/d1e9f0a5.html"/>
    <id>http://ymjava.cn/archives/d1e9f0a5.html</id>
    <published>2017-11-06T07:51:42.000Z</published>
    <updated>2017-11-09T06:58:06.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大话设计模式——读后感（2）"><a href="#大话设计模式——读后感（2）" class="headerlink" title="大话设计模式——读后感（2）"></a><center>大话设计模式——读后感（2）</center></h2><h3 id="Tip2"><a href="#Tip2" class="headerlink" title="Tip2"></a>Tip2</h3><h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><blockquote>
<p>备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>
</blockquote>
<p><img src="http://images2015.cnblogs.com/blog/527668/201601/527668-20160109144237450-356010664.jpg" alt=""></p>
<p>Originator（发起人）：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。</p>
<p>Originator可根据需要决定Memento存储Originator的哪些内部状态</p>
<p>Memento（备忘录）：负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。</p>
<p>备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到</p>
<p>先前状态所需的所有数据。</p>
<p>Caretaker（管理者）：负责保存好备忘录Memento，不能对备忘录的内存进行操作或检查。<br><a id="more"></a></p>
<h4 id="备忘录模式代码实现"><a href="#备忘录模式代码实现" class="headerlink" title="备忘录模式代码实现"></a>备忘录模式代码实现</h4><p>以一个Emp实体对象来作为例子</p>
<p>首先，创建一个发起人：发起人内部保存着需要备忘的属性，它负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//发起人：发起人内部有自身的内部状态，并且发起人可以创建备忘录和恢复备忘录</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpOriginator</span> </span>&#123;</div><div class="line">    <span class="comment">//需要备份的自身属性</span></div><div class="line">    <span class="keyword">private</span> String ename;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</div><div class="line">    <span class="comment">//备份</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EmpMemento <span class="title">memento</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmpMemento(<span class="keyword">this</span>);<span class="comment">//将当前自身对象备份</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//恢复</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recovery</span><span class="params">(EmpMemento emp)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.ename = emp.getEname();</div><div class="line">        <span class="keyword">this</span>.age = emp.getAge();</div><div class="line">        <span class="keyword">this</span>.salary = emp.getSalary();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//省略get，set和带参构造器</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建备忘录对象：<font color="red">备忘录就是用来备份发起人的数据，所以构造器需要提供一个发起人对象</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//备忘录对象</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpMemento</span> </span>&#123;</div><div class="line">    <span class="comment">//自身属性</span></div><div class="line">    <span class="keyword">private</span> String ename;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary; </div><div class="line">    <span class="comment">//构造备忘录对象时，需要传入一个需要备忘的对象（发起人）</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmpMemento</span><span class="params">(EmpOriginator emp)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.ename = emp.getEname();</div><div class="line">        <span class="keyword">this</span>.age = emp.getAge();</div><div class="line">        <span class="keyword">this</span>.salary = emp.getSalary();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//省略3个属性的set,get方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开始创建一个备忘录的管理者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//管理者：管理备忘录对象</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</div><div class="line">    <span class="comment">//需要管理的备忘录对象，这里也可以使用一个list容器来存储。这样可以备份多个点  </span></div><div class="line">    <span class="keyword">private</span> EmpMemento empMemento;</div><div class="line">    <span class="function"><span class="keyword">public</span> EmpMemento <span class="title">getEmpMemento</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> empMemento;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmpMemento</span><span class="params">(EmpMemento empMemento)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.empMemento = empMemento;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单次备份测试：测试只能备份一次的备忘录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    CareTaker taker = <span class="keyword">new</span> CareTaker();<span class="comment">//构建一个备忘录管理者</span></div><div class="line">    <span class="comment">//构建发起人</span></div><div class="line">    EmpOriginator emp = <span class="keyword">new</span> EmpOriginator(<span class="string">"张三"</span>, <span class="number">20</span>, <span class="number">4000</span>);</div><div class="line">    System.out.println(<span class="string">"第一次："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line">    <span class="comment">//备份</span></div><div class="line">    taker.setEmpMemento(emp.memento());</div><div class="line"></div><div class="line">    <span class="comment">//备份完了后再修改</span></div><div class="line">    emp.setEname(<span class="string">"李四"</span>);</div><div class="line">    emp.setAge(<span class="number">30</span>);</div><div class="line">    emp.setSalary(<span class="number">50000</span>);</div><div class="line">    <span class="comment">//然后再次打印</span></div><div class="line">    System.out.println(<span class="string">"修改后："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line"></div><div class="line">    <span class="comment">//开始恢复</span></div><div class="line">    emp.recovery(taker.getEmpMemento());</div><div class="line">    System.out.println(<span class="string">"恢复后："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<pre><code>第一次：张三---20---4000.0

修改后：李四---30---50000.0

恢复后：张三---20---4000.0
</code></pre><p>但是，这样的效果是只能备份一次。有时候我们需要备份多个点，根据需要来还原具体哪次的数据</p>
<h5 id="多次备份"><a href="#多次备份" class="headerlink" title="多次备份"></a>多次备份</h5><p>使用Stack来存储备份数据，进行多次备份。用Stack的好处是<font color="red">Stack是后进先出的</font>，也就是说：<strong>你最近一次备份的数据会优先获取到</strong>。</p>
<p>修改管理者中的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="comment">//管理者：管理备忘录对象</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</div><div class="line">    <span class="comment">//需要管理的备忘录对象，这里也可以使用一个list容器来存储。这样可以备份多个点</span></div><div class="line">    <span class="comment">//或者使用一个Stack栈来保存，因为Stack是后进先出的</span></div><div class="line">    <span class="keyword">private</span> Stack&lt;EmpMemento&gt; stack = <span class="keyword">new</span> Stack&lt;EmpMemento&gt;();</div><div class="line">    <span class="comment">//备份emp数据到栈中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mementoEmp</span><span class="params">(EmpMemento emp)</span></span>&#123;</div><div class="line">        stack.push(emp);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//从栈中获取最近一次备份的emp数据</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EmpMemento <span class="title">getEmpForStack</span><span class="params">()</span></span>&#123;    </div><div class="line">        <span class="keyword">if</span> (!stack.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> stack.peek();<span class="comment">//peek只获取，不删除</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//从栈中获取最近一次备份的emp数据,并且从栈中删除该数据</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EmpMemento <span class="title">getEmpForStackAndRemove</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (!stack.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> stack.pop();<span class="comment">//pop获取后删除该元素</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次测试：后进先出，也就是说。恢复的话恢复的是最后一次备份的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    CareTaker taker = <span class="keyword">new</span> CareTaker();<span class="comment">//构建一个备忘录管理者</span></div><div class="line">    <span class="comment">//构建发起人</span></div><div class="line">    EmpOriginator emp = <span class="keyword">new</span> EmpOriginator(<span class="string">"张三"</span>, <span class="number">20</span>, <span class="number">4000</span>);</div><div class="line">    System.out.println(<span class="string">"第一次："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line">    <span class="comment">//第1次备份</span></div><div class="line">    taker.mementoEmp(emp.memento());</div><div class="line"></div><div class="line">    <span class="comment">//备份完了后再修改</span></div><div class="line">    emp.setEname(<span class="string">"李四"</span>);</div><div class="line">    emp.setAge(<span class="number">30</span>);</div><div class="line">    emp.setSalary(<span class="number">50000</span>);</div><div class="line">    <span class="comment">//然后再次打印</span></div><div class="line">    System.out.println(<span class="string">"1修改后："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line">    <span class="comment">//第2次备份</span></div><div class="line">    taker.mementoEmp(emp.memento());</div><div class="line"></div><div class="line">    <span class="comment">//备份完了后再修改</span></div><div class="line">    emp.setEname(<span class="string">"李四2"</span>);</div><div class="line">    emp.setAge(<span class="number">32</span>);</div><div class="line">    emp.setSalary(<span class="number">52000</span>);</div><div class="line">    <span class="comment">//然后再次打印</span></div><div class="line">    System.out.println(<span class="string">"2修改后："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line">    <span class="comment">//第3次备份</span></div><div class="line">    taker.mementoEmp(emp.memento());</div><div class="line"></div><div class="line">    <span class="comment">//备份完了后再修改</span></div><div class="line">    emp.setEname(<span class="string">"李四3"</span>);</div><div class="line">    emp.setAge(<span class="number">33</span>);</div><div class="line">    emp.setSalary(<span class="number">32000</span>);</div><div class="line">    <span class="comment">//然后再次打印</span></div><div class="line">    System.out.println(<span class="string">"3修改后："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line">    <span class="comment">//第4次备份</span></div><div class="line">    taker.mementoEmp(emp.memento());</div><div class="line"></div><div class="line">    <span class="comment">//开始恢复</span></div><div class="line">    emp.recovery(taker.getEmpForStack());<span class="comment">//恢复的是第4次备份的数据（3修改后）</span></div><div class="line">    System.out.println(<span class="string">"恢复后："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<pre><code>第一次：张三---20---4000.0

1修改后：李四---30---50000.0

2修改后：李四2---32---52000.0

3修改后：李四3---33---32000.0

恢复后：李四3---33---32000.0
</code></pre><p>当然，也可以恢复之后把它从栈中删除。</p>
<p>测试：恢复之前从栈中删除两个最近的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开始恢复</span></div><div class="line">taker.getEmpForStackAndRemove();<span class="comment">//删除最近一次的备份</span></div><div class="line">taker.getEmpForStackAndRemove();<span class="comment">//删除最近一次的备份</span></div><div class="line">emp.recovery(taker.getEmpForStack());<span class="comment">//此时获取的是原来未删除时倒数第二次的备份</span></div><div class="line">System.out.println(<span class="string">"恢复后："</span>+emp.getEname()+<span class="string">"---"</span>+emp.getAge()+<span class="string">"---"</span>+emp.getSalary());</div></pre></td></tr></table></figure>
<p>此时的结果就是如下：可见，这里已经把2和3给删除了</p>
<pre><code>第一次：张三---20---4000.0

1修改后：李四---30---50000.0

2修改后：李四2---32---52000.0

3修改后：李四3---33---32000.0

恢复后：李四---30---50000.0
</code></pre><h4 id="总结-应用场景"><a href="#总结-应用场景" class="headerlink" title="总结-应用场景"></a>总结-应用场景</h4><ol>
<li><p>棋类游戏中的悔棋操作</p>
</li>
<li><p>软件中的撤销操作</p>
</li>
<li><p>数据库中的事务回滚操作</p>
</li>
<li><p>常用软件中的历史记录功能</p>
</li>
</ol>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>大话设计模式(带目录完整版).pdf</li>
<li><a href="http://www.cnblogs.com/meet/p/5116407.html" target="_blank" rel="external">备忘录模式（Memento） - FangZheng - 博客园</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大话设计模式——读后感（2）&quot;&gt;&lt;a href=&quot;#大话设计模式——读后感（2）&quot; class=&quot;headerlink&quot; title=&quot;大话设计模式——读后感（2）&quot;&gt;&lt;/a&gt;&lt;center&gt;大话设计模式——读后感（2）&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;Tip2&quot;&gt;&lt;a href=&quot;#Tip2&quot; class=&quot;headerlink&quot; title=&quot;Tip2&quot;&gt;&lt;/a&gt;Tip2&lt;/h3&gt;&lt;h4 id=&quot;备忘录模式&quot;&gt;&lt;a href=&quot;#备忘录模式&quot; class=&quot;headerlink&quot; title=&quot;备忘录模式&quot;&gt;&lt;/a&gt;备忘录模式&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/527668/201601/527668-20160109144237450-356010664.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Originator（发起人）：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。&lt;/p&gt;
&lt;p&gt;Originator可根据需要决定Memento存储Originator的哪些内部状态&lt;/p&gt;
&lt;p&gt;Memento（备忘录）：负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。&lt;/p&gt;
&lt;p&gt;备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到&lt;/p&gt;
&lt;p&gt;先前状态所需的所有数据。&lt;/p&gt;
&lt;p&gt;Caretaker（管理者）：负责保存好备忘录Memento，不能对备忘录的内存进行操作或检查。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://ymjava.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="http://ymjava.cn/archives/b585e161.html"/>
    <id>http://ymjava.cn/archives/b585e161.html</id>
    <published>2017-11-01T04:48:10.000Z</published>
    <updated>2017-11-09T06:58:14.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a><center>新的开始</center></h2><h3 id="初整理-——-大话设计模式Tip1-读后笔记"><a href="#初整理-——-大话设计模式Tip1-读后笔记" class="headerlink" title="初整理 ——  大话设计模式Tip1 读后笔记"></a>初整理 ——  大话设计模式Tip1 读后笔记</h3><h4 id="UML类图整理"><a href="#UML类图整理" class="headerlink" title="UML类图整理"></a>UML类图整理</h4><p><img src="https://s1.ax2x.com/2017/11/06/Bfzu3.png" alt="Bfzu3.png"></p>
<p>动物类 (‘+’ 表示public ，’-‘ 表示private，’#’表示protected)</p>
<ul>
<li>第一层类的名称 (抽象类是用斜体表示)</li>
<li>第二层类的特性</li>
<li>第三层类的函数方法</li>
</ul>
<p>飞翔 接口图</p>
<ul>
<li>顶层是\&lt;<interface\>&gt;显示</interface\></li>
<li>第二层是方法<a id="more"></a>
另一种接口表现法是棒棒糖表示法（表现的唐老鸭实现了‘讲人话’的方法）。</li>
</ul>
<ul>
<li>继承：空心三角形+实线 表示。</li>
<li>实现：空心三角形+虚线 表示。</li>
<li>关联：实线箭头 表示。</li>
<li>聚合：空心的菱形+实线箭头 表示。（聚合表示一种弱的‘拥有关系’，体现的是A对象可以包含B对象，但B对象不是A对象的一部分[DPE]）</li>
<li>合成：菱形+实线箭头，两端数字为基数，表示一端的类可以有几个实例。（合成是一种强的拥有关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样）</li>
<li>依赖：虚线箭头表示。</li>
</ul>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简单工厂模式：用一个单独的类来做这个创造实例的过程。</p>
<p><img src="https://s1.ax2x.com/2017/11/06/BfO8z.png" alt="BfO8z.png"></p>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>策略模式：是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。</p>
<p>策略模式的Strategy 类层次为Context 定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能，</p>
<p>策略模式的另一个优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。</p>
<p>当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy 类中，可以在使用这些行为的类中消除条件语句。</p>
<p>策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。（在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象。）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;新的开始&quot;&gt;&lt;a href=&quot;#新的开始&quot; class=&quot;headerlink&quot; title=&quot;新的开始&quot;&gt;&lt;/a&gt;&lt;center&gt;新的开始&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;初整理-——-大话设计模式Tip1-读后笔记&quot;&gt;&lt;a href=&quot;#初整理-——-大话设计模式Tip1-读后笔记&quot; class=&quot;headerlink&quot; title=&quot;初整理 ——  大话设计模式Tip1 读后笔记&quot;&gt;&lt;/a&gt;初整理 ——  大话设计模式Tip1 读后笔记&lt;/h3&gt;&lt;h4 id=&quot;UML类图整理&quot;&gt;&lt;a href=&quot;#UML类图整理&quot; class=&quot;headerlink&quot; title=&quot;UML类图整理&quot;&gt;&lt;/a&gt;UML类图整理&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2017/11/06/Bfzu3.png&quot; alt=&quot;Bfzu3.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;动物类 (‘+’ 表示public ，’-‘ 表示private，’#’表示protected)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一层类的名称 (抽象类是用斜体表示)&lt;/li&gt;
&lt;li&gt;第二层类的特性&lt;/li&gt;
&lt;li&gt;第三层类的函数方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;飞翔 接口图&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶层是\&amp;lt;&lt;interface\&gt;&amp;gt;显示&lt;/li&gt;
&lt;li&gt;第二层是方法
    
    </summary>
    
      <category term="设计模式" scheme="http://ymjava.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Let&#39;s Encrypt证书使用</title>
    <link href="http://ymjava.cn/archives/ec1907ff.html"/>
    <id>http://ymjava.cn/archives/ec1907ff.html</id>
    <published>2017-06-08T02:55:52.000Z</published>
    <updated>2017-11-02T06:03:09.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Let’s-Encrypt证书使用"><a href="#Let’s-Encrypt证书使用" class="headerlink" title="Let’s Encrypt证书使用"></a><center>Let’s Encrypt证书使用<center></center></center></h2><blockquote>
<p>certbot软件从Github直接下载，在CentOS6、7下执行都没有问题。</p>
</blockquote>
<h3 id="设置yum代码库"><a href="#设置yum代码库" class="headerlink" title="设置yum代码库"></a>设置yum代码库</h3><ul>
<li>certbot-auto运行是会自动连接下载依赖包，启用163(<a href="http://mirrors.163.com/.help/centos.html" target="_blank" rel="external">http://mirrors.163.com/.help/centos.html</a>) 和epel(<a href="https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F)库，提前准备好环境，更多查看https://certbot.eff.org/#centosrhel6-other" target="_blank" rel="external">https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F)库，提前准备好环境，更多查看https://certbot.eff.org/#centosrhel6-other</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</div><div class="line">2.mv CentOS6-Base-163.repo /etc/yum.repos.d/</div><div class="line">3.wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm</div><div class="line">4.rpm -ivh epel-release-latest-6.noarch.rpm</div></pre></td></tr></table></figure>
<p>修改CentOS6-Base-163.repo文件，将$releasever替换为6<br>修改epel.repo文件，将$releasever替换为6，将<a href="http://download.fedoraproject.org/pub/epel修改为https://mirrors.tuna.tsinghua.edu.cn/epel" target="_blank" rel="external">http://download.fedoraproject.org/pub/epel修改为https://mirrors.tuna.tsinghua.edu.cn/epel</a><br>运行以下命令生成缓存</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum clean all</div><div class="line">yum makecache</div></pre></td></tr></table></figure>
<p>安装git软件，也可直接从<a href="https://github.com/certbot/certbot下载" target="_blank" rel="external">https://github.com/certbot/certbot下载</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install git</div></pre></td></tr></table></figure></p>
<a id="more"></a> 
<h3 id="防火墙修改"><a href="#防火墙修改" class="headerlink" title="防火墙修改"></a>防火墙修改</h3><p>修改/etc/sysconfig/iptables<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysconfig/iptables</div></pre></td></tr></table></figure></p>
<p>查看是否有80、443端口允许访问记录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-A INPUT -i eth0 -p tcp -m tcp --dport 80 -j ACCEPT</div><div class="line">-A INPUT -i eth0 -p tcp -m tcp --dport 443 -j ACCEPT</div></pre></td></tr></table></figure></p>
<h3 id="获取Let’s-Encrypt证书"><a href="#获取Let’s-Encrypt证书" class="headerlink" title="获取Let’s Encrypt证书"></a>获取Let’s Encrypt证书</h3><p>certbot-auto运行是会自动连接下载依赖包，执行过程出现问题具体分析原因<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/certbot/certbot</div><div class="line"><span class="built_in">cd</span> certbot</div></pre></td></tr></table></figure></p>
<p>certbot-auto命令在root用户下执行，certbot-auto会执行更新certbot版本和安装依赖包，执行需要联网，有时较慢<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./certbot-auto certonly --standalone --email 你的邮箱 <span class="_">-d</span> 你的域名</div></pre></td></tr></table></figure></p>
<p>生成的证书放在/etc/letsencrypt/live/[网站域名]下，证书有效期3个月</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>cert.pem</td>
<td>服务端证书</td>
</tr>
<tr>
<td>chain.pem</td>
<td>浏览器需要的所有证书但不包括服务端证书，比如根证书和中间证书</td>
</tr>
<tr>
<td>fullchain.pem</td>
<td>包括了cert.pem和chain.pem的内容</td>
</tr>
<tr>
<td>privkey.pem</td>
<td>证书的私钥</td>
</tr>
</tbody>
</table>
<h3 id="Apache-设置"><a href="#Apache-设置" class="headerlink" title="Apache 设置"></a>Apache 设置</h3><p>Apache测试版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Server version: Apache/2.4.6 (CentOS)</div><div class="line">Server built:   Nov 14 2016 18:04:44</div></pre></td></tr></table></figure>
<p>修改/etc/httpd/conf.d/ssl.conf<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Listen 443 https</div><div class="line">&lt;VirtualHost _default_:443&gt;</div><div class="line">Header always <span class="built_in">set</span> Strict-Transport-Security <span class="string">"max-age=63072000; includeSubdomains; preload"</span></div><div class="line">SSLEngine on</div><div class="line">SSLCertificateFile /etc/letsencrypt/live/域名/cert.pem</div><div class="line">SSLCertificateKeyFile /etc/letsencrypt/live/域名/privkey.pem</div><div class="line">SSLCertificateChainFile /etc/letsencrypt/live/域名/fullchain.pem</div><div class="line">&lt;/VirtualHost&gt;</div></pre></td></tr></table></figure></p>
<p>HSTS（HTTP Strict Transport Security）的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。</p>
<h3 id="Tomcat设置"><a href="#Tomcat设置" class="headerlink" title="Tomcat设置"></a>Tomcat设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cp /etc/letsencrypt/live/域名/*.pem apache-tomcat-8.5.5/conf/</div><div class="line"><span class="built_in">cd</span> apache-tomcat-8.5.5/conf/</div><div class="line">chown 用户:组 *.pem</div></pre></td></tr></table></figure>
<p>修改conf/server.xml文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;Connector port=<span class="string">"8443"</span> protocol=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span></div><div class="line">           maxThreads=<span class="string">"150"</span> SSLEnabled=<span class="string">"true"</span> &gt;</div><div class="line">    &lt;UpgradeProtocol className=<span class="string">"org.apache.coyote.http2.Http2Protocol"</span> /&gt;</div><div class="line">    &lt;SSLHostConfig&gt;</div><div class="line">        &lt;Certificate certificateKeyFile=<span class="string">"conf/privkey.pem"</span></div><div class="line">                     certificateFile=<span class="string">"conf/cert.pem"</span></div><div class="line">                     certificateChainFile=<span class="string">"conf/fullchain.pem"</span></div><div class="line">                     <span class="built_in">type</span>=<span class="string">"RSA"</span> /&gt;</div><div class="line">    &lt;/SSLHostConfig&gt;</div><div class="line">&lt;/Connector&gt;</div></pre></td></tr></table></figure>
<h3 id="Nginx设置"><a href="#Nginx设置" class="headerlink" title="Nginx设置"></a>Nginx设置</h3><p>修改nginx的配置文件/usr/local/nginx/conf/nginx.conf，实现https转到内网tomcat的http服务，注：以下配置未实现tomcat识别来自https的请求，详细见问题3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">     listen 8443;</div><div class="line">     server_name localhost;</div><div class="line">     ssl on;</div><div class="line">     ssl_certificate /etc/letsencrypt/live/域名/fullchain.pem;</div><div class="line">     ssl_certificate_key /etc/letsencrypt/live/域名/privkey.pem;</div><div class="line">     server_name_in_redirect off;</div><div class="line">     proxy_set_header Host $host:$server_port;</div><div class="line">     proxy_connect_timeout 60s;</div><div class="line">     proxy_read_timeout 5400s;</div><div class="line">     proxy_send_timeout 5400s;</div><div class="line">     proxy_set_header X-Real-IP $remote_addr;</div><div class="line">     proxy_set_header REMOTE-HOST $remote_addr;</div><div class="line">     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line">     index index.html index.htm index.jsp index.do;</div><div class="line">     location ^~ /ZhsqApp/&#123;</div><div class="line">         proxy_pass  http://192.168.100.10:8080;</div><div class="line">         client_max_body_size    100m;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="Weblogic-配置"><a href="#Weblogic-配置" class="headerlink" title="Weblogic 配置"></a>Weblogic 配置</h3><p>weblogic必须是10.3.6及以上版本，才能使用Let’s Encrypt的证书，Let’s Encrypt采用SHA256withRSA，低版本的不支持SHA256withRSA</p>
<h3 id="生成密钥库"><a href="#生成密钥库" class="headerlink" title="生成密钥库"></a>生成密钥库</h3><p>执行openssl命令生成fullchain_and_key.p12，执行keytool命令生成密钥库文件weblogic.jks</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">openssl pkcs12 -export -in fullchain.pem -inkey privkey.pem -out fullchain_and_key.p12 -name weblogic -passout pass:123456</div><div class="line">keytool -importkeystore -deststorepass 123456   -destkeystore weblogic.jks -srckeystore fullchain_and_key.p12 -srcstoretype PKCS12 -srcstorepass 123456  -alias weblogic</div></pre></td></tr></table></figure>
<p>privkey.pem、fullchain.pem为Let’s Encrypt生成文件，密码可自行修改。注-name与-alias别名保存一致，-passout参数的pass:需保留。-passout与-srcstorepass密码保持一致， -deststorepass需记住在weblogic配置使用。</p>
<h3 id="生成信任库"><a href="#生成信任库" class="headerlink" title="生成信任库"></a>生成信任库</h3><p>执行keytool命令生成信任库文件trust.jks<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -importcert -alias rootCA -trustcacerts -file cert.pem -keystore trust.jks -storepass 123456</div></pre></td></tr></table></figure></p>
<p>cert.pem为Let’s Encrypt生成文件，密码可自行修改。 -storepass需记住在weblogic配置使用。</p>
<h3 id="weblogic配置"><a href="#weblogic配置" class="headerlink" title="weblogic配置"></a>weblogic配置</h3><h4 id="启用SSL监听端口"><a href="#启用SSL监听端口" class="headerlink" title="启用SSL监听端口"></a>启用SSL监听端口</h4><p>登录weblogic控制台 -&gt; 服务器 -&gt; 选择服务器管理 -&gt; 配置标签 -&gt; 一般信息子标签页 -&gt; 启用 SSL 监听端口 -&gt; 修改端口7002 -&gt; 保存</p>
<p>在Linux下设置端口小于1024的，需要使用管理员用户启动weblogic。</p>
<p><img src="http://f3e6036a.fromwiz.com/share/resources/b0c2bbb1-1a90-4b45-a09a-c7aa9804cd7c/index_files/64659649.png" alt=""></p>
<h4 id="密钥库配置"><a href="#密钥库配置" class="headerlink" title="密钥库配置"></a>密钥库配置</h4><p>进入配置标签 -&gt; 密钥库标签页</p>
<p>1.密钥库点更改，选择定制标识和定制信任，点击保存。<br>2.定制标识密钥库，填写weblogic.jks全路径<br>定制标识密钥库类型，填写jks<br>3.定制标识密钥库密码短语，填写生成密钥库时 -deststorepass写的密码<br>4.确认定制标识密钥库密码短语，填写生成密钥库时 -deststorepass写的密码<br>5.定制信任密钥库，填写trust.jks全路径<br>6.定制信任密钥库类型，填写jks<br>7.定制信任密钥库密码短语，填写生成信任库时 -storepass写的密码<br>8.确认定制信任密钥库密码短语，填写生成信任库时 -storepass写的密码</p>
<p><img src="http://f3e6036a.fromwiz.com/share/resources/b0c2bbb1-1a90-4b45-a09a-c7aa9804cd7c/index_files/65091944.png" alt=""></p>
<h4 id="SSL配置"><a href="#SSL配置" class="headerlink" title="SSL配置"></a>SSL配置</h4><p>进入配置标签 -&gt; SSL标签页</p>
<p>1.私有密钥别名，填写生成密钥库时的别名<br>2.私有密钥密码短语，填写生成密钥库时 -deststorepass写的密码<br>3.确认私有密钥密码短语，填写生成密钥库时 -deststorepass写的密码<br>点击保存</p>
<p><img src="http://f3e6036a.fromwiz.com/share/resources/b0c2bbb1-1a90-4b45-a09a-c7aa9804cd7c/index_files/65673128.png" alt=""></p>
<p>weblogic 10.3. 6 版本还需要做额外配置，SSL标签页中，点击高级，选中使用 JSSE SSL，点击保存</p>
<p><img src="http://f3e6036a.fromwiz.com/share/resources/b0c2bbb1-1a90-4b45-a09a-c7aa9804cd7c/index_files/65716484.png" alt=""></p>
<p>重启weblogic服务，测试https访问。</p>
<h3 id="更新证书"><a href="#更新证书" class="headerlink" title="更新证书"></a>更新证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./certbot-auto renew</div></pre></td></tr></table></figure>
<p>更新证书之后，需要执行tomcat、weblogic对应配置内容。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="问题1、Let’s-Encrypt安装好之后在PC端可以正常访问，但在手机端提示不受信任的"><a href="#问题1、Let’s-Encrypt安装好之后在PC端可以正常访问，但在手机端提示不受信任的" class="headerlink" title="问题1、Let’s Encrypt安装好之后在PC端可以正常访问，但在手机端提示不受信任的"></a>问题1、Let’s Encrypt安装好之后在PC端可以正常访问，但在手机端提示不受信任的</h4><p>主要原因是缺少中级证书。生成的LE证书后使用的需要使用fullchain.pem，打开后会发现有两段证书，第一段是LE的证书，第二段才是你网站的证书。而你只有网站的证书，而没有LE的证书。</p>
<h4 id="问题2、如何关闭SSL3协议"><a href="#问题2、如何关闭SSL3协议" class="headerlink" title="问题2、如何关闭SSL3协议"></a>问题2、如何关闭SSL3协议</h4><p>查看<a href="http://disablessl3.com如何关闭apache、nginx的ssl3协议" target="_blank" rel="external">http://disablessl3.com如何关闭apache、nginx的ssl3协议</a><br>tomcat修改，修改server.xml,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</div><div class="line">               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot;</div><div class="line">               sslProtocol=&quot;TLS&quot; sslEnabledProtocols=&quot;TLSv1,TLSv1.1,TLSv1.2&quot;  &gt;</div></pre></td></tr></table></figure>
<h4 id="问题3、nginx采用Let’s-Encrypt证书，如何实现https转http，后端识别来自https的请求"><a href="#问题3、nginx采用Let’s-Encrypt证书，如何实现https转http，后端识别来自https的请求" class="headerlink" title="问题3、nginx采用Let’s Encrypt证书，如何实现https转http，后端识别来自https的请求"></a>问题3、nginx采用Let’s Encrypt证书，如何实现https转http，后端识别来自https的请求</h4><p>1.修改nginx的配置文件<br>修改nginx的配置文件/usr/local/nginx/conf/nginx.conf，实现https转到内网tomcat的http服务，注：以下配置未实现tomcat识别来自https的请求，详细见问题2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 8443;</div><div class="line">    server_name localhost;</div><div class="line">    ssl on;</div><div class="line">    ssl_certificate /etc/letsencrypt/live/域名/fullchain.pem;</div><div class="line">    ssl_certificate_key /etc/letsencrypt/live/域名/privkey.pem;</div><div class="line">    server_name_in_redirect off;</div><div class="line">    proxy_set_header Host $host:$server_port;</div><div class="line">    proxy_connect_timeout 60s;</div><div class="line">    proxy_read_timeout 5400s;</div><div class="line">    proxy_send_timeout 5400s;</div><div class="line">    proxy_set_header X-Real-IP $remote_addr;</div><div class="line">    proxy_set_header REMOTE-HOST $remote_addr;</div><div class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line">              proxy_set_header X-Forwarded-Proto  $scheme;</div><div class="line">              proxy_set_header WL-Proxy-SSL true;</div><div class="line">              add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains;   &quot;;</div><div class="line">    index index.html index.htm index.jsp index.do;</div><div class="line">    location ^~ /ZhsqApp/&#123;</div><div class="line">        proxy_pass  http://192.168.100.10:8080;</div><div class="line">        client_max_body_size    100m;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>主要增加3处配置：</p>
<blockquote>
<p>proxy_set_header X-Forwarded-Proto  $scheme; tomcat可识别参数<br>proxy_set_header WL-Proxy-SSL true; weblogic可识别参数<br>add_header Strict-Transport-Security “max-age=63072000; includeSubdomains; “; 启用HSTS功能，浏览器在63072000秒时间内默认以https请求服务</p>
</blockquote>
<p>2.tomcat启用识别X-Forwarded-Proto设置<br>修改配置文件server.xml，在Engine下添加下面内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Valve className=&quot;org.apache.catalina.valves.RemoteIpValve&quot;   remoteIpHeader=&quot;X-Forwarded-For&quot;</div><div class="line">           protocolHeader=&quot;X-Forwarded-Proto&quot;</div><div class="line">           protocolHeaderHttpsValue=&quot;https&quot;/&gt;</div></pre></td></tr></table></figure>
<p>做好上述配置，重启tomcat。request.getScheme()的值显示https<br>另外，可参考Nginx SSL+tomcat集群,request.getScheme() 取到https正确的协议内容</p>
<p>3.weblogic启用识别WL-Proxy-SSL 设置<br>进入console界面，域名-&gt;配置-&gt;Web应用程序，勾选启用 WebLogic 插件，保存</p>
<p><img src="http://f3e6036a.fromwiz.com/share/resources/b0c2bbb1-1a90-4b45-a09a-c7aa9804cd7c/index_files/65317389.png" alt=""><br><img src="http://f3e6036a.fromwiz.com/share/resources/b0c2bbb1-1a90-4b45-a09a-c7aa9804cd7c/index_files/65382741.png" alt=""></p>
<p>做好上述配置，重启weblogic。request.getScheme()的值显示https<br>另外，可参考HTTPS/SSL/Spring Security doesn’t work in both a load balancer and non-load balancer environment #424内容</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Let’s-Encrypt证书使用&quot;&gt;&lt;a href=&quot;#Let’s-Encrypt证书使用&quot; class=&quot;headerlink&quot; title=&quot;Let’s Encrypt证书使用&quot;&gt;&lt;/a&gt;&lt;center&gt;Let’s Encrypt证书使用&lt;center&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;certbot软件从Github直接下载，在CentOS6、7下执行都没有问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;设置yum代码库&quot;&gt;&lt;a href=&quot;#设置yum代码库&quot; class=&quot;headerlink&quot; title=&quot;设置yum代码库&quot;&gt;&lt;/a&gt;设置yum代码库&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;certbot-auto运行是会自动连接下载依赖包，启用163(&lt;a href=&quot;http://mirrors.163.com/.help/centos.html&quot;&gt;http://mirrors.163.com/.help/centos.html&lt;/a&gt;) 和epel(&lt;a href=&quot;https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F)库，提前准备好环境，更多查看https://certbot.eff.org/#centosrhel6-other&quot;&gt;https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F)库，提前准备好环境，更多查看https://certbot.eff.org/#centosrhel6-other&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1.wget http://mirrors.163.com/.help/CentOS6-Base-163.repo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2.mv CentOS6-Base-163.repo /etc/yum.repos.d/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3.wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4.rpm -ivh epel-release-latest-6.noarch.rpm&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;修改CentOS6-Base-163.repo文件，将$releasever替换为6&lt;br&gt;修改epel.repo文件，将$releasever替换为6，将&lt;a href=&quot;http://download.fedoraproject.org/pub/epel修改为https://mirrors.tuna.tsinghua.edu.cn/epel&quot;&gt;http://download.fedoraproject.org/pub/epel修改为https://mirrors.tuna.tsinghua.edu.cn/epel&lt;/a&gt;&lt;br&gt;运行以下命令生成缓存&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;yum clean all&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;yum makecache&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;安装git软件，也可直接从&lt;a href=&quot;https://github.com/certbot/certbot下载&quot;&gt;https://github.com/certbot/certbot下载&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;yum install git&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术随记" scheme="http://ymjava.cn/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>spring ioc 控制反转</title>
    <link href="http://ymjava.cn/archives/50de3585.html"/>
    <id>http://ymjava.cn/archives/50de3585.html</id>
    <published>2017-03-04T13:15:00.000Z</published>
    <updated>2017-11-01T09:32:20.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-–-IOC"><a href="#Spring-–-IOC" class="headerlink" title="Spring – IOC"></a><center>Spring – IOC<center></center></center></h2><h3 id="spring-ioc-控制反转"><a href="#spring-ioc-控制反转" class="headerlink" title="spring ioc 控制反转"></a>spring ioc 控制反转</h3><pre><code>IOC（Inversion of Control）控制反转：本来是由应用程序管理的对象之间的依赖关系，现在交给了容器管理，这就叫控制反转，即交给了IOC容器，Spring的IOC容器主要使用DI方式实现的。不需要主动查找，对象的查找、定位和创建全部由容器管理。

通俗点说就是不创建对象。以前我们要调用一个对象的方法，首先要new一个对象。但使用IOC容器，在代码中不直接与对象连接，而是在配置文件中描述要使用哪一个对象。容器负责将这些联系在一起。
</code></pre><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><pre><code>IOC容器的对象实例化是通过配置文件来实现的。术语上这叫做注入。注入有两种形式，采用构造方法注入和采用setter注入。具体的注入形式如下
</code></pre><a id="more"></a> 
<p>采用set方法注入，给属性添加一个set方法，并对其进行赋值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">publicclass UserManagerImplimplements UserManager &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> UserDaouserDao;</div><div class="line"></div><div class="line">    <span class="function">publicvoid <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.userDao = userDao;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;beanid="userManager"class="com.bjpowernode.spring.manager.UserManagerImpl"&gt;</div><div class="line"></div><div class="line">     &lt;propertyname="userDao"ref="usrDao4Oracle"/&gt;</div><div class="line"></div><div class="line">  &lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>set注入特点：</p>
<pre><code> 与传统的JavaBean的写法更相似，程序员更容易理解、接受，通过setter方式设定依赖关系显得更加直观、明显；

 对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致死你功能下降。而使用设置注入，则避免这下问题；

尤其在某些属性可选的情况下，多参数的构造器更加笨拙。
</code></pre><p>采用构造方法注入，在构造方法中对属性进行赋值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">publicclass UserManagerImplimplements UserManager &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> UserDaouserDao;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserManagerImpl</span><span class="params">(UserDao userDao)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.userDao = userDao;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置文件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;beanid="userManager"class="com.bjpowernode.spring.manager.UserManagerImpl"&gt;</div><div class="line"></div><div class="line">    &lt;constructor-argref="userDao4Mysql"/&gt;</div><div class="line"></div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>构造方法注入特点：</p>
<pre><code> 构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。

 对于依赖关系无须变化的Bean，构造注入更有用处；因为没有setter方法，所有的依赖关系全部在构造器内设定，因此，不用担心后续代码对依赖关系的破坏。
依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系。对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则；
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-–-IOC&quot;&gt;&lt;a href=&quot;#Spring-–-IOC&quot; class=&quot;headerlink&quot; title=&quot;Spring – IOC&quot;&gt;&lt;/a&gt;&lt;center&gt;Spring – IOC&lt;center&gt;&lt;/h2&gt;&lt;h3 id=&quot;spring-ioc-控制反转&quot;&gt;&lt;a href=&quot;#spring-ioc-控制反转&quot; class=&quot;headerlink&quot; title=&quot;spring ioc 控制反转&quot;&gt;&lt;/a&gt;spring ioc 控制反转&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;IOC（Inversion of Control）控制反转：本来是由应用程序管理的对象之间的依赖关系，现在交给了容器管理，这就叫控制反转，即交给了IOC容器，Spring的IOC容器主要使用DI方式实现的。不需要主动查找，对象的查找、定位和创建全部由容器管理。

通俗点说就是不创建对象。以前我们要调用一个对象的方法，首先要new一个对象。但使用IOC容器，在代码中不直接与对象连接，而是在配置文件中描述要使用哪一个对象。容器负责将这些联系在一起。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;实现方法&quot;&gt;&lt;a href=&quot;#实现方法&quot; class=&quot;headerlink&quot; title=&quot;实现方法&quot;&gt;&lt;/a&gt;实现方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;IOC容器的对象实例化是通过配置文件来实现的。术语上这叫做注入。注入有两种形式，采用构造方法注入和采用setter注入。具体的注入形式如下
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="java学习之路" scheme="http://ymjava.cn/categories/java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="java" scheme="http://ymjava.cn/tags/java/"/>
    
      <category term="IOC（Inversion of Control）控制反转" scheme="http://ymjava.cn/tags/IOC%EF%BC%88Inversion-of-Control%EF%BC%89%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>js学习之promise</title>
    <link href="http://ymjava.cn/archives/fddbb00f.html"/>
    <id>http://ymjava.cn/archives/fddbb00f.html</id>
    <published>2017-02-21T11:01:28.000Z</published>
    <updated>2017-11-01T09:32:28.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js学习之promise"><a href="#js学习之promise" class="headerlink" title="js学习之promise"></a><center>js学习之promise<center></center></center></h2><h3 id="Promise的初步认识"><a href="#Promise的初步认识" class="headerlink" title="Promise的初步认识"></a>Promise的初步认识</h3><p>我们之前在完成异步执行都是利用的回调函数去实现的，例如ajax的调用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 新建XMLHttpRequest对象</span></div><div class="line"></div><div class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></div><div class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></div><div class="line">        <span class="comment">// 判断响应结果:</span></div><div class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</div><div class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></div><div class="line">            <span class="keyword">return</span> success(request.responseText);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></div><div class="line">            <span class="keyword">return</span> fail(request.status);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// HTTP请求还在继续...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 发送请求:</span></div><div class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/api/categories'</span>);</div><div class="line">request.send();</div><div class="line"></div><div class="line">alert(<span class="string">'请求已发送，请等待响应...'</span>);</div></pre></td></tr></table></figure></p>
<a id="more"></a> 
<p>当然我们可以封装起来，改成另外的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ajax = ajaxGet(<span class="string">'http://...'</span>);</div><div class="line">ajax.ifSuccess(success)</div><div class="line">    .ifFail(fail);</div></pre></td></tr></table></figure></p>
<p>但是我们从ES6后我们有了新的写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(test).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'成功：'</span> + result);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'失败：'</span> + reason);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当然这只是简单的promise的利用，进阶版本请看参考链接。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>&gt;<br>1.<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000" target="_blank" rel="external">Promise - 廖雪峰的官方网站</a><br>2.<a href="http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/" target="_blank" rel="external">[翻译] We have a problem with promises - FEX</a><br>3.<a href="http://liubin.org/promises-book/" target="_blank" rel="external">JavaScript Promise迷你书（中文版）</a></p>
<hr>
<h3 id="前方的路很长，还需努力啊"><a href="#前方的路很长，还需努力啊" class="headerlink" title="前方的路很长，还需努力啊"></a>前方的路很长，还需努力啊</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;js学习之promise&quot;&gt;&lt;a href=&quot;#js学习之promise&quot; class=&quot;headerlink&quot; title=&quot;js学习之promise&quot;&gt;&lt;/a&gt;&lt;center&gt;js学习之promise&lt;center&gt;&lt;/h2&gt;&lt;h3 id=&quot;Promise的初步认识&quot;&gt;&lt;a href=&quot;#Promise的初步认识&quot; class=&quot;headerlink&quot; title=&quot;Promise的初步认识&quot;&gt;&lt;/a&gt;Promise的初步认识&lt;/h3&gt;&lt;p&gt;我们之前在完成异步执行都是利用的回调函数去实现的，例如ajax的调用：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; request = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; XMLHttpRequest(); &lt;span class=&quot;comment&quot;&gt;// 新建XMLHttpRequest对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;request.onreadystatechange = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;// 状态发生变化时，函数被回调&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (request.readyState === &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 成功完成&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 判断响应结果:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (request.status === &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 成功，通过responseText拿到响应的文本:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; success(request.responseText);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 失败，根据响应码判断失败原因:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fail(request.status);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// HTTP请求还在继续...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 发送请求:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;request.open(&lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;/api/categories&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;request.send();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(&lt;span class=&quot;string&quot;&gt;&#39;请求已发送，请等待响应...&#39;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js学习之路" scheme="http://ymjava.cn/categories/js%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="js" scheme="http://ymjava.cn/tags/js/"/>
    
      <category term="nodejs" scheme="http://ymjava.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>travis部署Hexo之填坑日记</title>
    <link href="http://ymjava.cn/archives/a8653e18.html"/>
    <id>http://ymjava.cn/archives/a8653e18.html</id>
    <published>2017-02-17T08:34:46.000Z</published>
    <updated>2017-11-01T09:32:36.729Z</updated>
    
    <content type="html"><![CDATA[<p>这个小客栈总算是被我搭起来了，前前后后遇到了不少坑。果然每一次在网上学东西都是遇坑填坑的过程，不过这都是为了我们更好的成（zhuang）长(bi)嘛。</p>
<p>也就不重复的讲其他教程里有的内容了，只简明的记录下，我的填坑过程。</p>
<h3 id="第一个坑-travis-找不指定文件"><a href="#第一个坑-travis-找不指定文件" class="headerlink" title="第一个坑 travis 找不指定文件"></a>第一个坑 travis 找不指定文件</h3><a id="more"></a> 
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> 博客项目文件夹根目录</div><div class="line">$ touch .travis.yml</div></pre></td></tr></table></figure>
<ul>
<li>登录 travis<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">travis login --auto</div><div class="line">`</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这里的 REPO_TOKEN 是变量名,在后面的配置文件中会用到</span></div><div class="line"><span class="comment"># TOKEN 是上面github生成的Token</span></div><div class="line">travis encrypt <span class="string">'REPO_TOKEN=&lt;TOKEN&gt;'</span> --add</div></pre></td></tr></table></figure>
<p>这在很多讲解Travis部署Hexo的教程中都有的步骤，那么问题就出现了。。。。</p>
<ul>
<li>travis 找不到指定文件</li>
</ul>
<p>这里是在travis encrypt 你的github创建的token的时候出现的。</p>
<p>解决办法： 在travis encrypt ‘REPO_TOKEN=<token>‘ –add 的时候加上 -r 你的github用户民/你的repo名。比如我的就是</token></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">travis encrypt <span class="string">'REPO_TOKEN=&lt;TOKEN&gt;'</span> --add -r Nanmen/nanmen.github.io</div></pre></td></tr></table></figure>
<h3 id="第二个坑-travis-构建你的工程时报2-gt-dev-null错的问题"><a href="#第二个坑-travis-构建你的工程时报2-gt-dev-null错的问题" class="headerlink" title="第二个坑 travis 构建你的工程时报2&gt; dev/null错的问题"></a>第二个坑 travis 构建你的工程时报2&gt; dev/null错的问题</h3><ul>
<li>当我兴高采烈的去推送到我的dev分支的时候，travis 运行测试过程中报出个 ‘\<token> 2&gt;dev/null’ 的错误，一脸懵有没有，明明都是按照教程来的，怎么会是这样的呢。在我前后回想之后，一不小心测试出来了。。。。</token></li>
</ul>
<p>解决办法： 在你执行travis encrypt 的时候，并不是跟大部分教程写的那样，应该执行这一句<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">travis encrypt REPO_TOKEN=TOKEN --add -r Nanmen/nanmen.github.io</div></pre></td></tr></table></figure></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="http://www.jianshu.com/p/f4cc5866946b" target="_blank" rel="external">手把手教从零开始在GitHub上使用Hexo搭建博客教程(一)-附GitHub注册及配置 - 简书</a><br>  2.<a href="http://www.jianshu.com/p/fff7b3384f46" target="_blank" rel="external">手把手教从零开始在GitHub上使用Hexo搭建博客教程(四)-使用Travis自动部署Hex… - 简书</a><br>  3.<a href="http://blog.csdn.net/xuezhisdc/article/details/53130423" target="_blank" rel="external">hexo教程系列——使用Travis自动部署hexo - 张学志の博客 - 博客频道 - CSDN.NET</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个小客栈总算是被我搭起来了，前前后后遇到了不少坑。果然每一次在网上学东西都是遇坑填坑的过程，不过这都是为了我们更好的成（zhuang）长(bi)嘛。&lt;/p&gt;
&lt;p&gt;也就不重复的讲其他教程里有的内容了，只简明的记录下，我的填坑过程。&lt;/p&gt;
&lt;h3 id=&quot;第一个坑-travis-找不指定文件&quot;&gt;&lt;a href=&quot;#第一个坑-travis-找不指定文件&quot; class=&quot;headerlink&quot; title=&quot;第一个坑 travis 找不指定文件&quot;&gt;&lt;/a&gt;第一个坑 travis 找不指定文件&lt;/h3&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://ymjava.cn/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="http://ymjava.cn/tags/hexo/"/>
    
  </entry>
  
</feed>
